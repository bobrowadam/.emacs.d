#+TITLE: Grain Utils
#+AUTHOR: Bob
#+PROPERTY: header-args:elisp :tangle grain-utils.el :comments link

This module contains utilities for working with the Grain financial services platform.
* Dependencies
#+begin_src elisp
  (require 'ansi-color)
#+end_src
* Grain Project Detection and Setup
#+begin_src elisp
  (defun bob/setup-grain-project-for-worktree (path)
    "Setup grain worktree in PATH."
    (message "Setup grain worktree in %s" path)
    (let ((default-directory path))
      (fnm-use)
      (message "Running npm install in %s" path)
      (async-shell-command "npm i"
                           (format "*npm install in %s" path)
                           (format "*npm install errors in %s" path)))
    (make-symbolic-link (expand-file-name "~/dotfiles/.claude/")
                        (expand-file-name (format "%s/.claude/" path)))

    (make-symbolic-link (expand-file-name "~/dotfiles/CLAUDE.local.md")
                        (expand-file-name (format "%s/CLAUDE.local.md" path)))
    (shell-command "npm run rules:sync -- --agent=agentsmd")
    (copy-file (expand-file-name "AGENTS.md" path)
               (expand-file-name "CLAUDE.md") t)
    (copy-file (expand-file-name "~/source/grain/.env")
               (expand-file-name ".env" path) t)
    (copy-file (expand-file-name "~/source/grain/build.number")
               (expand-file-name "build.number" path) t))

  (defun bob/is-grain-project (path)
    "Check if PATH is a grain project."
    (let ((default-directory path))
      (equal (bob/npm--project-name) "grain")))

  (defun bob/setup-worktree-checkout (orig-fun path worktree)
    (funcall orig-fun path worktree)
    (message "checkout worktree %s in path %s" worktree path)
    (when (bob/is-grain-project path)
      (bob/setup-grain-project-for-worktree path)))

  (defun bob/setup-worktree-branch (orig-fun path worktree &optional starting-point)
    (if starting-point (funcall orig-fun path worktree starting-point)
      (funcall orig-fun path worktree))
    (message (format "created worktree %s in path %s starting at %s" worktree path starting-point))
    (when (bob/is-grain-project path)
      (bob/setup-grain-project-for-worktree path)))

  (advice-add 'magit-worktree-delete :around #'bob/remove-project-roots-advice)
  (advice-add 'magit-worktree-checkout :around #'bob/setup-worktree-checkout)
  (advice-add 'magit-worktree-branch :around #'bob/setup-worktree-branch)
  (advice-add 'magit-worktree-move :around
              (lambda (orig-fun worktree path)
                (funcall orig-fun worktree path)
                (message (format "moving worktree %s to path %s" worktree path))
                (when (bob/is-grain-project path)
                  (bob/setup-grain-project-for-worktree path))))
#+end_src

* Service Management
** Logic
*** Globals
#+begin_src elisp
  (defconst *grain-services-root* "apps/backend/")
  (defvar *grain-active-processes* '()
    "Registry of active Grain service processes.
  Each entry is a plist with keys:
    :process - the actual process object
    :type - service type (:individual :all-services :dashboard :admin-console)
    :name - service name or description
    :buffer - associated buffer name")
#+end_src

*** Processes Management
#+begin_src elisp
  (defun grain/register-process (process type name buffer-name)
    "Register PROCESS with TYPE, NAME and BUFFER-NAME in the active processes registry."
    (push (list :process process :type type :name name :buffer buffer-name)
          ,*grain-active-processes*))

  (defun grain/unregister-process (process)
    "Remove PROCESS from the active processes registry."
    (setq *grain-active-processes*
          (cl-remove-if (lambda (entry)
                          (eq (plist-get entry :process) process))
                        ,*grain-active-processes*)))

  (defun grain/get-active-processes ()
    "Get all active Grain processes."
    (cl-remove-if-not (lambda (entry)
                        (process-live-p (plist-get entry :process)))
                      ,*grain-active-processes*))

  (defun grain/cleanup-dead-processes ()
    "Remove dead processes from the registry."
    (setq *grain-active-processes* (grain/get-active-processes)))
#+end_src

*** Running services
#+begin_src elisp
  (defun bob/generate--run-service-command (service-name env inspect-port)
    "Generate a shell command to run SERVICE-NAME.
    optionally, accept ENV and INSPECT-PORT arguments."
    (let ((project-root (expand-file-name (bob/monorepo-root))))
      (format "NODE_ENV=%s TS_NODE_PROJECT='%sapps/backend/%s/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/%s/src/**/*' --exec \"node --inspect%s -r ts-node/register -r tsconfig-paths/register ./apps/backend/%s/src/index.ts\""
              (or env "development")
              project-root
              service-name
              service-name
              (if inspect-port (format "=%s" inspect-port) "")
              service-name)))

  (defun bob/generate--run-all-services-command (excluded-service-name)
    "Run all off grain services except EXCLUDED-SERVICE-NAME."
    (format "npx nx run-many --target=start --parallel=20 --exclude=%s"
            excluded-service-name))

  (defun bob/generate--run-all-services-e2e-command (excluded-service-name)
    "Run all off grain services in e2e mode, except EXCLUDED-SERVICE-NAME."
    (format "npm run start:services:test -- --exclude %s"
            excluded-service-name))

  (defun grain/run--service (run-service-command service-output-buffer-name service-type service-name)
    "Run RUN-SERVICE-COMMAND in SERVICE-OUTPUT-BUFFER-NAME buffer.
  SERVICE-TYPE and SERVICE-NAME are used for process registry tracking.
  Assumes default-directory is already set to the repo root."
    ;; Kill existing process if running
    (when-let ((existing-buffer (get-buffer service-output-buffer-name))
               (existing-process (get-buffer-process existing-buffer)))
      (grain/unregister-process existing-process)
      (interrupt-process existing-process)
      (kill-buffer existing-buffer))

    ;; Create buffer and start new process
    (let* ((buffer (get-buffer-create service-output-buffer-name))
           (process (start-process-shell-command
                     (format "grain-%s" service-name)
                     buffer
                     run-service-command)))

      ;; Enable shell-mode for proper shell functionality and set up keybindings
      (with-current-buffer buffer
        (shell-mode)
        (font-lock-mode 1)
        ;; Add nodemon-specific restart keybinding (rs command)
        (let ((map (make-sparse-keymap)))
          (set-keymap-parent map (current-local-map))
          (define-key map (kbd "C-c C-r")
            (lambda ()
              (interactive)
              (when-let ((proc (get-buffer-process (current-buffer))))
                (process-send-string proc "rs\n"))))
          (use-local-map map)))

      ;; Set up xterm color processing for the process
      (set-process-filter process
                          (lambda (proc string)
                            (when (buffer-live-p (process-buffer proc))
                              (with-current-buffer (process-buffer proc)
                                (let ((moving (= (point) (process-mark proc))))
                                  (save-excursion
                                    (goto-char (process-mark proc))
                                    (insert (xterm-color-filter string))
                                    (set-marker (process-mark proc) (point)))
                                  (if moving (goto-char (process-mark proc))))))))

      ;; Register the process in our registry
      (grain/register-process process service-type service-name service-output-buffer-name)

      ;; Set up process sentinel to handle cleanup
      (set-process-sentinel process
                            (lambda (proc event)
                              (when (memq (process-status proc) '(exit signal))
                                (grain/unregister-process proc))))

      process))

  (defun grain/get--service-name ()
    "Use completing read to get a name of a known grain service."
    (if-let* ((repo-root (bob/monorepo-root))
              (is-grain-project (bob/is-grain-project repo-root)))
        (completing-read "Enter service name: "
                         (directory-files (file-name-concat repo-root *grain-services-root*)
                                          nil
                                          "^[^.]"))
      (ignore (message "Not in a grain monorepo worktree"))))

    ;;;###autoload
  (defun grain/run-service (single-service-p)
    "Run a service in debug mode.
    When SINGLE-SERVICE-P is nil, run all the other services as well."
    (interactive "P")
    (when-let* ((service-name (grain/get--service-name))
                (service-output-buffer (format "*SERVICE: %s*" service-name))
                (all-services-output-buffer (format "*[ALL] except %s*" service-name)))
      ;; Set up environment once for all services
      (let ((default-directory (bob/monorepo-root)))
        ;; Set Node.js environment according to .nvmrc
        (fnm-use)
        (save-excursion
          (grain/run--service
           (bob/generate--run-service-command service-name
                                              "development"
                                              (get-next-available-inspect-port))
           service-output-buffer
           :individual
           service-name))
        (unless single-service-p
          (grain/run--service (bob/generate--run-all-services-command service-name)
                              all-services-output-buffer
                              :all-services
                              (format "all-except-%s" service-name)))
        (unless (get-buffer "*Dashboard*")
          (grain/run--service "npm run dev -w @grain/dashboard"
                              "*Dashboard*"
                              :dashboard
                              "dashboard"))
        (unless (get-buffer "*Admin Console*")
          (grain/run--service "npm run dev -w @grain/admin-console"
                              "*Admin Console*"
                              :admin-console
                              "admin-console"))
        (switch-to-buffer service-output-buffer))))

    ;;;###autoload
  (defun grain/run-e2e ()
    "Run a service in debug mode and all the other services as well."
    (interactive)
    (when-let ((service-name (grain/get--service-name)))
      ;; Set up environment once for all services
      (let ((default-directory (bob/monorepo-root)))
        ;; Set Node.js environment according to .nvmrc
        (fnm-use)
        (grain/run--service (bob/generate--run-service-command service-name
                                                               "test"
                                                               (get-next-available-inspect-port))
                            (format "*SERVICE: %s*" service-name)
                            :individual
                            service-name)
        (grain/run--service (bob/generate--run-all-services-e2e-command service-name)
                            (format "*[ALL] except %s*" service-name)
                            :all-services
                            (format "all-e2e-except-%s" service-name)))))

    ;;;###autoload
  (defun grain/shutdown-services ()
    "Shutdown all running Grain services using the process registry."
    (interactive)
    (let ((killed-processes '())
          (killed-buffers '()))

      ;; Clean up dead processes first
      (grain/cleanup-dead-processes)

      ;; Get all active processes
      (let ((active-processes (grain/get-active-processes)))
        (if (null active-processes)
            (message "No running Grain services found.")

          ;; Shutdown each active process
          (dolist (entry active-processes)
            (let* ((process (plist-get entry :process))
                   (buffer-name (plist-get entry :buffer))
                   (service-name (plist-get entry :name))
                   (buffer (get-buffer buffer-name)))

              ;; Interrupt and delete the process
              (when (process-live-p process)
                (interrupt-process process)
                (delete-process process)
                (push service-name killed-processes))

              ;; Kill the buffer if it exists
              (when buffer
                (kill-buffer buffer)
                (push buffer-name killed-buffers))

              ;; Unregister the process
              (grain/unregister-process process)))

          ;; Report results
          (message "Shutdown complete. Terminated %d service(s): %s. Killed %d buffer(s): %s"
                   (length killed-processes)
                   (mapconcat 'identity killed-processes ", ")
                   (length killed-buffers)
                   (mapconcat 'identity killed-buffers ", "))))))
#+end_src

** Tests
#+begin_src elisp
  (ert-deftest generate-command-basic ()
    "Test basic command generation with development environment and no inspect port."
    (let ((mock-root "/test/path/"))
      (cl-letf (((symbol-function 'bob/monorepo-root) (lambda () mock-root)))
        (should (equal (bob/generate--run-service-command "mail-service" "development" nil)
                       "NODE_ENV=development TS_NODE_PROJECT='/test/path/apps/backend/mail-service/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/mail-service/src/**/*' --exec \"node --inspect -r ts-node/register -r tsconfig-paths/register ./apps/backend/mail-service/src/index.ts\"")))))

  (ert-deftest generate-command-test-environment ()
    "Test command generation with test environment."
    (let ((mock-root "/test/path/"))
      (cl-letf (((symbol-function 'bob/monorepo-root) (lambda () mock-root)))
        (should (equal (bob/generate--run-service-command "liquidity-service" "test" nil)
                       "NODE_ENV=test TS_NODE_PROJECT='/test/path/apps/backend/liquidity-service/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/liquidity-service/src/**/*' --exec \"node --inspect -r ts-node/register -r tsconfig-paths/register ./apps/backend/liquidity-service/src/index.ts\"")))))

  (ert-deftest generate-command-with-inspect-port ()
    "Test command generation with inspect port specified."
    (let ((mock-root "/test/path/"))
      (cl-letf (((symbol-function 'bob/monorepo-root) (lambda () mock-root)))
        (should (equal (bob/generate--run-service-command "payments-service" "development" 9230)
                       "NODE_ENV=development TS_NODE_PROJECT='/test/path/apps/backend/payments-service/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/payments-service/src/**/*' --exec \"node --inspect=9230 -r ts-node/register -r tsconfig-paths/register ./apps/backend/payments-service/src/index.ts\"")))))

  (ert-deftest generate-command-nil-environment ()
    "Test command generation with nil environment (should default to development)."
    (let ((mock-root "/test/path/"))
      (cl-letf (((symbol-function 'bob/monorepo-root) (lambda () mock-root)))
        (should (equal (bob/generate--run-service-command "trading-service" nil nil)
                       "NODE_ENV=development TS_NODE_PROJECT='/test/path/apps/backend/trading-service/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/trading-service/src/**/*' --exec \"node --inspect -r ts-node/register -r tsconfig-paths/register ./apps/backend/trading-service/src/index.ts\"")))))

  (ert-deftest generate-command-empty-root ()
    "Test command generation when monorepo root is empty."
    (let ((current-dir (expand-file-name default-directory)))
      (cl-letf (((symbol-function 'bob/monorepo-root) (lambda () "")))
        (should (equal (bob/generate--run-service-command "mail-service" "development" nil)
                       (format "NODE_ENV=development TS_NODE_PROJECT='%sapps/backend/mail-service/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/mail-service/src/**/*' --exec \"node --inspect -r ts-node/register -r tsconfig-paths/register ./apps/backend/mail-service/src/index.ts\"" current-dir))))))

  ;; Backward compatibility test - keep the old test name as an alias
  (defalias 'generate-command 'generate-command-basic)
#+end_src

** Key Bindings

#+begin_src elisp
  (global-set-key (kbd "C-c b r") 'grain/run-service)
  (global-set-key (kbd "C-c b s") 'grain/shutdown-services)
#+end_src

* Debug Port Management
#+begin_src elisp
  ;;;###autoload
  (defun get-next-available-inspect-port (&optional default-port)
    "Calculate the next available port for node inspector to use.
  When all ports are available use DEFAULT-PORT or return 9229."
    (if-let ((inspected-ports (mapcar 'cdr (get-inspected-node-processes))))
        (->> inspected-ports
             (-sort #'string>)
             (car)
             (string-to-number)
             (1+))
      (or default-port 9229)))

  ;;;###autoload
  (defun pick-port-for-inspected-service ()
    "Ask for a service and find it's debugging port for."
    (let ((inspected-services-map (get-inspected-node-processes)))
      (-> (completing-read "Service to debug: "
                           inspected-services-map)
          (assocdr inspected-services-map)
          (or "9229"))))

  (defun get-inspected-node-processes ()
    "Get node processes that is running using the --inspect flag."
    (-filter 'identity (mapcar 'find--port-and-service-name-from-process-command
                               (mapcar #'process-command (process-list)))))

  (defun find--port-and-service-name-from-process-command (process-command)
    "Extract the service-name and port from PROCESS-COMMAND."
    (--some (or (port-and-service-name it)
                (jest-port-and-service-name it))
            process-command))

  (defun jest-port-and-service-name (proc-command)
    "Get the inspected port and service name when PROC-COMMAND is a Jest run command."
    (when-let* ((port-and-name (string-match jest-port-and-service-name-regex
                                             proc-command))
                (service-name (match-string 2 proc-command))
                (port (match-string 1 proc-command)))
      (cons (format "jest/%s" service-name) port)))

  (defconst jest-port-and-service-name-regex
    (rx (: "node --inspect"
           (*? anychar)
           "="
           (group (1+ digit))
           space
           (*? anychar)
           "jest"
           (*? anychar)
           "apps/backend/"
           (group (+? anychar))
           "/")))

  (defun port-and-service-name (proc-command)
    "Get the inspected port and service name from PROC-COMMAND."
    (when-let ((port-and-name (string-match port-and-service-name
                                            proc-command)))
      (let ((service-name (match-string 2 proc-command))
            (port (match-string 1 proc-command)))
        (cons service-name port))))

  (defconst port-and-service-name
    (rx (: "node --inspect"
           (*? anychar)
           "="
           (group (1+ digit))
           space
           "-r ts-node/register"
           (*? anychar)
           "apps/backend/"
           (group (+? anychar))
           "/"
           (*? anychar))))
#+end_src

* Migration Debugging

#+begin_src elisp
  ;;;###autoload
  (defun debug-migration ()
    "Debug a grain migration script."
    (interactive)
    (let ((runOrRevert (completing-read "Command: " '("run" "revert")))
          (default-directory "/Users/bob/source/grain/packages/rdb/"))
      (async-shell-command (format "node --inspect --require ts-node/register ../../node_modules/typeorm/cli.js migration:%s -d src/data-source.ts"
                                   runOrRevert)
                           "*migration-shell*")))
#+end_src

* Database Utilities

#+begin_src elisp
  (defvar *local-pg-connection* nil
    "Connection to local PostgreSQL database.")
  (defvar *prod-pg-connection* nil
    "Connection to production PostgreSQL database.")

  (defconst *grain-select-from-prod-query-template*
    "select * from historical_exchange_rates where from_currency = '%s' and to_currency = '%s' order by timestamp DESC limit 1;")

  (defconst *grain-insert-from-prod-query-template*
    "INSERT INTO historical_exchange_rates (from_currency, to_currency,\"timestamp\",\"quote\",created_at,updated_at,deleted_at) VALUES
         ('%s','%s','%s',%f,'%s','%s',NULL);")

  (defun pg--date-string (timestamp)
    "Format TIMESTAMP as a PostgreSQL date string."
    (format-time-string "%Y-%m-%d %H:%M:%S" timestamp))

  (defun grain-insert-rates-query (prod-rates)
    "Generate an insert query for PROD-RATES."
    (let ((from-currency (nth 0 prod-rates))
          (to-currency (nth 1 prod-rates))
          (timestamp (pg--date-string (nth 2 prod-rates)))
          (quote (nth 3 prod-rates))
          (created-at (pg--date-string (nth 4 prod-rates)))
          (updated-at (pg--date-string (nth 5 prod-rates))))
      (format *grain-insert-from-prod-query-template*
              to-currency
              from-currency
              timestamp
              quote
              created-at
              updated-at)))

  (defun import-rate-from-prod (from to)
    "Import rate from prod using FROM as and TO currencies."
    (interactive "sFrom currency: \nsTo currency: ")
    (unless (boundp 'pg)
      (require 'pg))
    (let* ((auth-entry (auth-source-search :host "grain-prod-postgres" :max 1))
           (user (plist-get (car auth-entry) :user))
           (password (funcall (plist-get (car auth-entry) :secret)))
           (url (plist-get (car auth-entry) :url))
           (prod-rates (with-pg-connection prod-pg-connection
                                           ("grain" user password url 5432)
                                           (pg-result (pg-exec prod-pg-connection
                                                               (format *grain-select-from-prod-query-template*
                                                                       (upcase from)
                                                                       (upcase to)))
                                                      :tuple 0 ))))
      (with-pg-connection local-pg-connection ("grain" "postgres" "grain" "localhost" 5432)
                          (pg-result (pg-exec local-pg-connection
                                              (grain-insert-rates-query prod-rates))
                                     :tuples))))
#+end_src

* API Connection Utilities

#+begin_src elisp
  (require 'cl)

  (cl-defun bob/create-authenticated-api-connection (password username &key (type "POST"))
    "Create a closure with authenticated http connection for PASSWORD and USERNAME."
    (lexical-let ((password password)
                  (username username))
      (cl-function (lambda (url &key (iterations 10) (data '()))
                     (dotimes (i iterations)
                       (request url
                         :type type
                         :data (when data (json-encode data))
                         :parser 'json-read
                         :headers `(("X-Customer-IP" . "213.8.10.146")
                                    ("Content-Type" . "application/json")
                                    ("Authorization" . ,(format "Basic %s"
                                                                (base64-encode-string (format "%s:%s"
                                                                                              username
                                                                                              password)
                                                                                      t))))
                         :success 'bob/on-success
                         :error 'bob/on-error
                         :complete 'bob/on-complete))))))

  (cl-defun bob/on-success (&key data &allow-other-keys)
    "Success callback for DATA."
    (f-write (prin1-to-string data) 'utf-8 "/Users/bob/exchange-rates.el"))

  (cl-defun bob/on-error (&key error-thrown &allow-other-keys)
    "Error callback for ERROR-THROWN."
    (message "Error:\n%s" (cdr error-thrown)))

  (cl-defun bob/on-complete (&key response error-thrown symbol-status &allow-other-keys)
    "Completion callback for RESPONSE or ERROR-THROWN with SYMBOL-STATUS."
    (message "Done with status code: %s, symbol-status: %s"
             (request-response-status-code response)
             (request-response-symbol-status response)))

  (defun bob/update-historical-rates ()
    "Insert historical-exchange-rates records with rates from currency pairs file."
    (interactive)
    (unless (boundp 'pg)
      (require 'pg))

    ;; Read and parse the data files
    (let* ((rates-data (read (f-read "~/exchange-rates.el")))
           (currency-pairs (read (f-read "~/currency-pairs-for-historical-exchange-update.el")))
           (rates-alist (cdr (assoc 'rates rates-data)))
           (current-timestamp (format-time-string "%Y-%m-%d %H:%M:%S.000")))

      ;; Set up database connection
      (let* ((auth-entry (auth-source-search :host "grain-prod-postgres-write!" :max 1))
             (user (plist-get (car auth-entry) :user))
             (password (funcall (plist-get (car auth-entry) :secret)))
             (url (plist-get (car auth-entry) :url)))

        ;; Connect to database and insert rates
        (with-pg-connection pg-connection ("grain" user password url 5432)
                            (dolist (pair currency-pairs)
                              (let* ((from-currency (symbol-name (car pair)))
                                     (to-currency (symbol-name (cadr pair)))
                                     (from-rates (cdr (assoc (car pair) rates-alist)))
                                     (rate (when from-rates
                                             (cdr (assoc (cadr pair) from-rates)))))

                                (when rate
                                  (message "Inserting rate for %s to %s: %s" from-currency to-currency rate)

                                  ;; Insert query matching your table structure
                                  (let ((insert-query
                                         (format "INSERT INTO historical_exchange_rates (to_currency, from_currency, \"timestamp\", \"quote\", created_at, updated_at, deleted_at) VALUES ('%s', '%s', '%s', %f, NOW(), NOW(), NULL)"
                                                 to-currency from-currency current-timestamp rate)))

                                    (condition-case err
                                        (pg-exec pg-connection insert-query)
                                      (error
                                       (message "Error inserting %s->%s: %s" from-currency to-currency err)))))))

                            (message "Historical exchange rates insertion completed")))))
#+end_src

* Grain's monorepo eslint --fix
#+begin_src elisp
  (defun bob/grain-lint-on-save ()
    "Run npm run lint:modified -- --fix on the grain monorepo root after each save."
    (when (and (buffer-file-name)
               (project-current)
               (bob/is-grain-project (bob/monorepo-root)))
      (let ((default-directory (bob/monorepo-root)))
        (start-process "grain-lint" "*grain-lint*" "npm" "run" "lint:modified" "--" "--fix"))))

  (defun bob/enable-grain-lint-on-save ()
    "Enable automatic linting on save for grain projects."
    (add-hook 'after-save-hook #'bob/grain-lint-on-save nil t))

  (defun bob/maybe-enable-grain-lint ()
    "Enable grain lint on save if we're in a grain project
   and editing relevant files."
    (when (and (buffer-file-name)
               (bob/is-grain-project (bob/monorepo-root))
               (derived-mode-p '(typescript-mode typescript-ts-mode js-ts-mode tsx-ts-mode jtsx-jsx-mode)))
      (bob/enable-grain-lint-on-save)))
#+end_src

* Provide Feature
#+begin_src elisp
  (provide 'grain-utils)
#+end_src
