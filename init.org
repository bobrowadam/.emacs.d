#+title: Bob's Emacs init file

* Startup
** Set lexical binding
#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src
** Elpaca and Use package config
#+begin_src emacs-lisp
  (setq use-package-verbose t)
  (setq use-package-enable-imenu-support t)
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t)
  (setq use-package-compute-statistics t)
  (elpaca elpaca-use-package
    (elpaca-use-package-mode)
    (setq elpaca-use-package-by-default t))
  (defun compile-init-file ()
    "Compile init.org file."
    (when (get-buffer "init.org")
      (kill-buffer "init.org"))
    (org-babel-load-file "/Users/bob/.emacs.d/init.org"))
  (add-hook 'kill-emacs-hook 'compile-init-file)
  (elpaca-wait)
  (setq custom-file (concat user-emacs-directory "./custom.el"))
#+end_src
* Which key
#+begin_src elisp
  (use-package which-key
    :init (which-key-mode 1))
#+end_src
* Init Server
#+begin_src elisp
  (use-package server
    :ensure nil
    :demand t
    :when window-system
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

* Global elisp dependencies
#+begin_src elisp
  (use-package dash
    :config (defalias '-range '-iota))
  (use-package s :ensure (:wait t) :demand t)
  (use-package llama
    :ensure (:wait t)
    :commands (𝝺)
    :hook (emacs-lisp . llama-fontify-mode)
    :config (defalias '𝝺 'llama))
  (use-package uuid)
  (use-package transient)
  (use-package exec-path-from-shell)
  (use-package xref)
  (use-package buff-menu :ensure nil)
  (use-package jsonrpc)
#+end_src

* My elisp utils
#+begin_src elisp
  (defun assocdr (prop cons-cell)
    "Get the cdr of an association with key PROP in CONS-CELL.
  This is a shorthand for (cdr (assoc prop cons-cell))."
    (cdr (assoc prop cons-cell)))

  (defun get-dir-name (&optional path)
    "Get the current directory name from PATH.
  If PATH is nil, use `default-directory'."
    (file-name-nondirectory
     (directory-file-name
      (file-name-directory (or path default-directory)))))

  (defun bob/read-file-content (file-name)
    "Read the content of FILE-NAME and return it as a string."
    (with-temp-buffer
      (when (insert-file-contents file-name)
        (buffer-string))))

  (defun bob/drop-buffer (buffers)
    (seq-remove (lambda (buf)
                  (cond ((equal buf (buffer-name)) t)))
                buffers))

  (defun bob/kill-this-buffer ()
    (interactive)
    (if (one-window-p)
        (kill-buffer)
      (kill-buffer-and-window)))

  (defun bob/eat-top-project ()
    "Open an Eat shell on the highest project"
    (interactive)
    (if-let* ((project--root (bob/monorepo-root))
              (default-directory project--root))
        (eat-project)
      (error "Not in project")))

  (defvar bob/last-shell-buffer nil)

  (defun set-last-shell-buffer-as-first (buffers)
    (seq-sort (lambda (a b)
                (equal a bob/last-shell-buffer))
              buffers))


  (defun bob/jump-to-shell ()
    "Jump to a shell buffer."
    (interactive)
    (if-let* ((shell-buffers
               (bob/drop-buffer
                (set-last-shell-buffer-as-first
                 (seq-filter
                  (lambda (b) (or (equal (with-current-buffer b major-mode) 'vterm-mode)
                                  (equal (with-current-buffer b major-mode) 'eshell-mode)
                                  (with-current-buffer b (derived-mode-p 'comint-mode))
                                  (with-current-buffer b (derived-mode-p 'compilation-mode))
                                  (equal (with-current-buffer b major-mode) 'sly-mrepl-mode)
                                  (equal (with-current-buffer b major-mode) 'eat-mode)
                                  (equal (with-current-buffer b major-mode) 'sql-interactive-mode)
                                  (equal (with-current-buffer b major-mode) 'pgmacs-mode)))
                  (mapcar (function buffer-name)
                          (buffer-list))))))
              (shell-buffer (consult--read shell-buffers
                                           :prompt "Shell: "
                                           :category 'buffer
                                           :state (consult--buffer-state)
                                           :sort nil)))
        (progn
          (setq bob/last-shell-buffer shell-buffer)
          (switch-to-buffer shell-buffer))
      (message "No Shell buffers exists")))

  (defun get--inspect-processes-port ()
    (cl-remove-if-not 'identity
                      (mapcar
                       (lambda (process)
                         (if-let ((match (s-match "inspect=\\([0-9]+\\)" (nth 2 (process-command process)))))
                             (string-to-number (cadr match))))
                       (cl-remove-if-not
                        (lambda (p) (s-contains? "comint" (process-name p)))
                        (process-list)))))

  (defun get--available-inspect-port ()
    (if-let (inspect-processes (get--inspect-processes-port))
        (1+ (car (-sort '> inspect-processes)))
      9229))

  (defun check-types-command ()
    "Returns the command for running check-types NPM script if available"
    (when-let* ((default-directory (locate-dominating-file default-directory "package.json"))
                (package-json-raw (bob/read-file-content "package.json"))
                (package-json (json-parse-string package-json-raw
                                                 :object-type 'alist)))
      (assocdr 'check-types (assocdr 'scripts package-json))))

  (defun bob/npm--project-name ()
    "Get the current project name from the package json file."
    (when-let ((project (project-current))
               (project-root-path (project-root project))
               (package-json-file-path (format "%s/package.json" project-root-path))
               (package-json (and
                              (file-exists-p package-json-file-path)
                              (json-parse-string (bob/read-file-content
                                                  (format "%s/package.json" project-root-path))
                                                 :object-type 'alist))))
      (assocdr 'name package-json)))

  (defun bob/compilation-buffer-name ()
    (if-let ((projcet-path (nth 2 (project-current))))
        (format "TS-COMPILE -- %s"
                (get-dir-name projcet-path))))

  (defun npm-run (&optional normal-mode)
    "Debug typescript project on watch mode.
  NORMAL-MODE is for not running with debugger"
    (interactive "P")
    (when (check-types-command)
      (let ((default-directory (project-root (project-current t)))
            (comint-scroll-to-bottom-on-input t)
            (comint-scroll-to-bottom-on-output t)
            (comint-process-echoes t)
            (compilation-buffer-name (bob/compilation-buffer-name))
            (project-main-file (bob/npm--project-name)))
        (cond ((and (not (eq major-mode 'comint-mode))
                    (car (memq (get-buffer compilation-buffer-name)
                               (buffer-list))))
               (switch-to-buffer (get-buffer compilation-buffer-name)))
              ((and (eq major-mode 'comint-mode)
                    (s-contains? (buffer-name (current-buffer)) compilation-buffer-name))
               (switch-to-prev-buffer))
              (t
               (let ((compilation-command (if normal-mode
                                              (format "./node_modules/typescript/bin/tsc -w& nodemon -d 2 -w ./dist -r source-map-support/register ./dist/%s.js"
                                                      project-main-file)
                                            (format "./node_modules/typescript/bin/tsc -w& nodemon -d 2 --inspect=%s -w ./dist -r source-map-support/register ./dist/%s.js"
                                                    (get--available-inspect-port)
                                                    project-main-file))))
                 (with-temporary-node-version
                     (fnm-current-node-version)
                   (compilation-start compilation-command
                                      t (lambda (mode)
                                          compilation-buffer-name)))))))))

  (defun npm-run-build ()
    "Build typescript project on watch mode"
    (interactive)
    (if-let* ((default-directory (locate-dominating-file default-directory "package.json"))
              (local-check-types-command (check-types-command))
              (comint-scroll-to-bottom-on-input t)
              (comint-scroll-to-bottom-on-output t)
              (comint-process-echoes t)
              (compilation-buffer-name (format "TS-COMPILE -- %s"
                                               (get-dir-name default-directory))))
        (cond ((and (not (eq major-mode 'comint-mode))
                    (car (memq (get-buffer compilation-buffer-name)
                               (buffer-list))))
               (switch-to-buffer (get-buffer compilation-buffer-name)))
              ((and (eq major-mode 'comint-mode)
                    (s-contains? (buffer-name (current-buffer)) compilation-buffer-name))
               (switch-to-prev-buffer))
              ((s-starts-with-p "nx" local-check-types-command)
               (compilation-start "npm run check-types"
                                  t (lambda (_)
                                      compilation-buffer-name)))
              (t
               (compilation-start "npm run check-types -- -w"
                                  t (lambda (_)
                                      compilation-buffer-name))))
      (error "probably not a typescript application")))

  (defun read-file (file-name)
    "Return the contents of FILE-NAME as a lisp data type."
    (when (file-exists-p file-name)
      (with-temp-buffer
        (insert-file-contents file-name)
        (buffer-string))))

  (defun bob/get-unix-timestamp ()
    "Return the current Unix timestamp as an integer."
    (floor (float-time (current-time))))

  (defmacro bob/with-default-dir (directory &rest body)
    "Evaluate BODY with 'default-dir' as DIRECTORY. keymap is \\{typescript-ts-mode-map}"
    (declare (indent 1) (debug t))
    `(let ((default-directory ,directory))
       ,@body))

  (defun get--processes-by-string (captured-string)
    (-let [lines (-filter
                  (lambda (str)
                    (not (string-match-p (regexp-quote "rg") str)))
                  (s-split "\n" (shell-command-to-string (format "ps aux | rg %s" captured-string)) t))]
      (mapcar (lambda (line)
                (nth 1 (s-split " " line t)))
              lines)))

  (defun bob/kill-inspect-process ()
    (interactive)
    (-let ((process (get--processes-by-string "inspect")))
      (if process
          (progn (message "Found inspect processes: %s, killing them now" process)
                 (when (equal (shell-command (format "kill %s" (s-join " " process)))
                              0)
                   (message "Killed inspect processes: %s" process)))
        (message "No inspect processes found"))))

  (defun make-sentence (string)
    "Create a sentence out of any STRING."
    (let* ((lowerCamelCased (string-inflection-underscore-function string))
           (splitted (string-split lowerCamelCased "_")))
      (s-capitalize (string-join splitted
                                 " "))))
#+end_src

* GC improvements
#+begin_src elisp
  (use-package gcmh
    :init (gcmh-mode 1))
#+end_src

* Basic settings
#+begin_src elisp
  (setq read-process-output-max (* 3 1024 1024)) ;; 3mb
  (setq browse-url-chrome-program "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome")
  (setq user-login-name "Adam Bobrow"
        user-full-name "Adam Bobrow"
        garbage-collection-messages nil
        undo-limit (* 30 1024 1000)
        scroll-preserve-screen-position t
        make-backup-files nil
        enable-recursive-minibuffers t
        inhibit-splash-screen t
        inhibit-startup-message t
        require-final-newline nil
        truncate-partial-width-windows 80
        sentence-end-double-space t       ; explicitly choose default
        x-select-enable-clipboard t
        set-mark-command-repeat-pop t
        mark-ring-max 30
        global-mark-ring-max 40
        history-delete-duplicates t
        comint-input-ignoredups t
        view-read-only nil          ; all read-only buffers in view-mode
        view-inhibit-help-message t ; don't tell me about it
        gdb-many-windows t
        epa-pinentry-mode 'loopback
        auth-sources '("~/.authinfo" "~/.authinfo.gpg" "~/.netrc")
        dired-recursive-deletes 'always
        dired-recursive-copies 'always
        display-time-day-and-date t
        display-time-24hr-format t
        display-time-default-load-average nil
        shift-select-mode nil
        Info-additional-directory-list `(,(expand-file-name "info-docs" user-emacs-directory))
        ring-bell-function 'ignore
        visible-bell nil
        tab-width 4
        enable-local-eval t
        enable-local-variables t
        dictionary-server "dict.org"
        tab-always-indent 'complete
        text-mode-ispell-word-completion nil)

  (setq read-extended-command-predicate #'command-completion-default-include-p)
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  ;; FrogFind is a simple search engine for text based browsers
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")

  (when (boundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode 1))

  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (unless (not (file-exists-p custom-file))
    (load custom-file))

  (setq-default indent-tabs-mode nil)

  (when (window-system)
    (setq confirm-kill-emacs 'yes-or-no-p))

  (defalias 'yes-or-no-p 'y-or-n-p)

  (blink-cursor-mode 0)
  (global-subword-mode t)
  (global-superword-mode -1)
  (delete-selection-mode 1)
  (global-auto-revert-mode 1)
  (auto-compression-mode t)
  (global-word-wrap-whitespace-mode t)

  ;; delete char and delte word with "C-h" "C-M-h"
  (define-key key-translation-map [?\C-h] [?\C-?])
  (define-key key-translation-map (kbd "<f1>") (kbd "C-h"))
  ;; And also in Hebrew
  (define-key key-translation-map [?\C-י] [?\C-?])
  (global-unset-key (kbd "s-n"))

  ;; Deal with editing large files:
  (global-so-long-mode 1)
  (defun disable-modes-for-large-files ()
    "Disable minor modes for large files."
    (when (and buffer-file-name
               (> (buffer-size) (* 1024 1024)))
      (fundamental-mode)))
  (add-hook 'find-file-hook 'disable-modes-for-large-files)

  ;; Put backup files neatly away
  (let ((backup-dir "~/tmp/emacs/backups")
        (auto-saves-dir "~/tmp/emacs/auto-saves/"))
    (dolist (dir (list backup-dir auto-saves-dir))
      (when (not (file-directory-p dir))
        (make-directory dir t)))
    (setq backup-directory-alist `(("." . ,backup-dir))
          auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
          auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
          tramp-backup-directory-alist `((".*" . ,backup-dir))
          tramp-auto-save-directory auto-saves-dir)
    (setq vc-handled-backends '(Git)))

  (setq backup-by-copying t    ; Don't delink hardlinks
        delete-old-versions t  ; Clean up the backups
        version-control t      ; Use version numbers on backups,
        kept-new-versions 5    ; keep some new versions
        kept-old-versions 2)   ; and some old ones, too

  (setq linum-format "%4d  ")

  ;; Set Emacs C source dir:
  (setq find-function-C-source-directory "~/source/emacs/src")

  ;; On my mac I accidentally zoomed in and out with my palm
  (global-unset-key (kbd "C-<wheel-up>"))
  (global-unset-key (kbd "C-<wheel-down>"))

  (global-unset-key (kbd "C-M-<mouse-5>"))
  (global-unset-key (kbd "C-M-<mouse-4>"))
  (global-unset-key (kbd "C-M-<wheel-down>"))
  (global-unset-key(kbd "C-M-<wheel-up>"))

  ;; Map movement keys to Hebrew letters:
  (global-set-key (kbd "C-כ") 'forward-char)
  (global-set-key (kbd "C-נ") 'backward-char)
  (global-set-key (kbd "C-מ") 'next-line)
  (global-set-key (kbd "C-פ") 'previous-line)
  (global-set-key (kbd "C-ש") 'beginning-of-line)
  (global-set-key (kbd "C-ק") 'end-of-line)
  (global-set-key (kbd "C-c T") 'display-time-mode)

  ;; scroll pages conservatively
  (defun consertive-page-upδ ()
    "Scroll up half a page and try to preserve cursor position."
    (interactive)
    (let ((line-num (count-lines (window-start) (point))))
      (scroll-down-command (round (* (window-body-height) 0.25)))
      (move-to-window-line line-num)))

  (defun consertive-page-downδ ()
    "Scroll down half a page and try to preserve cursor position."
    (interactive)
    (let ((line-num (count-lines (window-start) (point))))
      (scroll-up-command (round (* (window-body-height) 0.25)))
      (move-to-window-line line-num)))

  (global-set-key (kbd "C-v") 'consertive-page-downδ)
  (global-set-key (kbd "M-v") 'consertive-page-upδ)

  (defun scroll-forward-lineδ ()
    "Scroll  forward a single line."
    (interactive)
    (forward-line 1)
    (recenter))
  (defun scrol-backward-lineδ ()
    "Scroll backward a single line."
    (interactive)
    (forward-line -1)
    (recenter))
  (global-set-key (kbd "C-s-p") 'scrol-backward-lineδ)
  (global-set-key (kbd "C-s-n") 'scroll-forward-lineδ)
  (global-set-key (kbd "C-x 8 l")
                  (lambda ()
                    (interactive (insert "𝝺"))))
  (global-set-key (kbd "C-x 8 d")
                  (lambda ()
                    (interactive (insert "δ"))))

  (setq xref-search-program 'ripgrep)

  (setq python-shell-interpreter (executable-find "python3.12"))

  (setq custom-safe-themes t)
  (setq custom-theme-directory (concat user-emacs-directory "themes"))

  (let ((calculated-font-size
         (if (>= (nth 3 (assoc 'geometry (frame-monitor-attributes))) 1920)
             25
           23)))
    ;; (set-frame-font (format "Iosevka-%d:weight=medium:width=expanded" calculated-font-size)
    ;;                 'keep-size t)
    (set-frame-font (format "Aporetic Sans Mono-%d" calculated-font-size)
                    'keep-size t))
  (setq kill-buffer-query-functions nil)

  ;; Trust the ~/source/ file so flymake byte compile will work.
  (add-to-list 'trusted-content "~/source/")

  (defun bob/emacs-keyboard-quit (&optional force)
    "`keyboard-quit' that kill the minibuffer but doesn't FORCE quit kmacros."
    (interactive "P")

    ;; Inspiration from
    ;; https://emacsredux.com/blog/2025/06/01/let-s-make-keyboard-quit-smarter/
    (when (derived-mode-p 'completion-list-mode)
      (delete-completion-window))
    (when (> (minibuffer-depth) 0)
      (abort-recursive-edit))

    ;; Do the regular `keyboard-quit' unless defining or executing a keyboard
    ;; macro in which case we do the subset of `keyboard-quit' that *doesn't*
    ;; kill kmacros.
    (if (or force (not (or defining-kbd-macro executing-kbd-macro)))
        (keyboard-quit)

      (setq saved-region-selection nil)
      (let (select-active-regions)
        (deactivate-mark))
      (when completion-in-region-mode
        (completion-in-region-mode -1))))

  (global-set-key [remap keyboard-quit] #'bob/emacs-keyboard-quit)

  (eval-when-compile
    (dolist (sym '(cl-flet lisp-complete-symbol))
      (setplist sym (use-package-plist-delete
                     (symbol-plist sym) 'byte-obsolete-info))))
  (use-package emacs
    :ensure nil
    :demand
    :bind
    ("C-S-s" . isearch-forward-thing-at-point)
    ("C-x j" . whitespace-cleanup)
    ("C-^" . (lambda () (interactive (delete-indentation -1))))
    ("M-C-h" . backward-kill-sexp)
    ("C-x -" . bob/golden-ratio)
    ("C-x f" . recentf-open-files)
    ("C-x k" . bob/kill-this-buffer)
    ("M-SPC" . cycle-spacing)
    ("<s-return>" . toggle-frame-fullscreen)
    ("M-o" . other-frame))
#+end_src

* Ibuffer
#+begin_src elisp
  (use-package ibuffer
    :ensure nil
    :bind ("C-x C-b" . #'ibuffer))
#+end_src

* Search
#+begin_src elisp
  (use-package isearch
    :ensure nil
    :custom
    (isearch-lazy-count t))
  (use-package flx)
  (use-package swiper
    :config
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    :bind ("C-c C-s" . swiper))
#+end_src

* AI and LLM integrations
** GPTEL
#+begin_src elisp
  (defvar ai-assistant-prompt "
  You are a large language model living in Emacs and a helpful assistant. Respond concisely and as short as possible.

  TOOL USAGE STRATEGY:
  When handling code-related requests, follow this analysis approach:

  1. CONTEXT GATHERING:
     - When the context is >~500 lines, use the `summarize-chat-buffer` to compact the context. This is very important!
     - Use `get_project_root` and `get_buffers_name_in_project` to understand project structure
     - Use `run_rg` to search for patterns, functions, or specific code constructs
     - Use `find_files_by_regex_in_project` to locate relevant files

  2. CODE ANALYSIS:
     - Use `eglot_context` for precise symbol analysis (definitions, references, documentation)
     - Always specify buffer_name, symbol, and line_number when available
     - Use `get_flymake_diagnostics` to check for errors/warnings in relevant buffers

  3. INVESTIGATION WORKFLOW:
     - Start broad (search patterns with rg)
     - Narrow down (examine specific files/buffers)
     - Go deep (use LSP for symbol-level analysis)
     - Cross-reference (check related symbols and dependencies)

  4. RESPONSE STRUCTURE:
     - State what you're investigating
     - Show the analysis steps taken
     - Provide findings with LSP-backed evidence
     - Suggest next actions if applicable

  When code issues arise, prioritize LSP-based analysis over assumptions. Use the structured knowledge from eglot_context to provide precise, compiler-grade insights rather than generic advice.

  [rest of original prompt about conciseness, error handling, etc.]
  Respond concisely and as short as possible.
  When using tools, tell me what you are about to do. don't ever apologize if some error happened or if you were wrong in working with the tool. If you are not able to use the tool let me know what you think is the problem and let me debug it.
  Be very aware of the tool API and the arguments it needs. failing to do so will cause an unrecoverable error in the flow.
  Since I'm paying for the LLM usage and my workplace doesn't help me, try to use as little tokens as you can. thanks!")
  (use-package gptel
    :custom
    (gptel-default-mode 'org-mode)
    (gptel-max-tokens 600)
    :config
    (exec-path-from-shell-initialize)
    (add-to-list 'gptel-directives (cons 'ai-assitant ai-assistant-prompt))
    (mapcar (apply-partially #'apply #'gptel-make-tool)
            (llm-tool-collection-get-all))
    (defun bob/gptel-switch-to-gptel-buffer ()
      "Switch to a buffer with `gptel-mode' active."
      (interactive)
      (if-let ((gptel-buffers
                (seq-filter
                 (lambda (buff)
                   (with-current-buffer buff
                     (bound-and-true-p gptel-mode)))
                 (buffer-list)))
               (gptel-buffer (completing-read "GPT buffer: " (mapcar 'buffer-name gptel-buffers))))
          (switch-to-buffer gptel-buffer)
        (message "No GPTel buffers found.")))
    (gptel-make-ollama "Ollama"
      :host "localhost:11434"
      :stream t
      :models '(mistral:latest llama3.2:latest))
    (when-let ((credentials
                (setenv "ANTHROPIC_API_KEY"
                        (-some->
                            (plist-get (car (auth-source-search :host "claude.ai")) :secret)
                          funcall))))
      (setq
       gptel-model 'claude-sonnet-4-20250514
       gptel-backend
       (gptel-make-anthropic
           "Claude"
         :stream t
         :key credentials)))
    :bind
    ("C-c g g" . gptel)
    ("C-c g r" . gptel-rewrite)
    ("C-c g a d" . gptel-context-add)
    ("C-c g a f" . gptel-context-add-file)
    ("C-c g z" . bob/gptel-switch-to-gptel-buffer)
    (:map gptel-mode-map ("C-c g s" . gptel-menu))
    :hook
    (org-mode . (lambda ()
                  (when (-some->> (buffer-file-name) (s-match "^.+gptel\.org$" ))
                    (gptel-mode 1)))))
#+end_src
** Aider
#+begin_src elisp
  (use-package aider
    :ensure (:repo "tninja/aider.el" :fetcher github :files ("*.el"))
    :custom
    (aider-args '("--model" "sonnet" "--no-auto-accept-architect" "--no-auto-commits"))
    :config
    (setenv "ANTHROPIC_API_KEY"
            (-some-> (plist-get (car (auth-source-search :host "claude.ai")) :secret) funcall))
    :bind ("C-c g c" . 'aider-transient-menu)
    (:map prog-mode-map ("C-c g C" . 'aider-code-change)))
#+end_src

** Minuet - ai code completion
#+begin_src elisp
  (use-package minuet
    :custom
    (minuet-provider 'claude)
    :bind
    (:map prog-mode-map ("C-M-i" . #'minuet-complete-with-minibuffer))
    :config
    (setenv "ANTHROPIC_API_KEY"
            (-some-> (plist-get (car (auth-source-search :host "claude.ai")) :secret) funcall))

    (defvar minuet-claude-options
      `(:model "claude-3-haiku-20240307"
               :max_tokens 512
               :api-key "ANTHROPIC_API_KEY"
               :system
               (:template minuet-default-system-template
                          :prompt minuet-default-prompt
                          :guidelines minuet-default-guidelines
                          :n-completions-template minuet-default-n-completion-template)
               :fewshots minuet-default-fewshots
               :chat-input
               (:template minuet-default-chat-input-template
                          :language-and-tab minuet--default-chat-input-language-and-tab-function
                          :context-before-cursor minuet--default-chat-input-before-cursor-function
                          :context-after-cursor minuet--default-chat-input-after-cursor-function)
               :optional nil)
      "config options for Minuet Claude provider"))
#+end_src
** My llm-tools
My llm tools defintion with an init function
#+begin_src elisp
  (defun init-llm-tools ()
    (progn
      (llm-tool-collection-deftool delete-file
                                   (:category "filesystem" :tags (filesystem editing) :confirm t :include t)
                                   ((filename "The full filename including the path to create" :type string))
                                   "Create a new directory at the specified path if it does not already
  exist."
                                   (if (file-exists-p filename)
                                       (progn (delete-file filename t)
                                              (format "Deleted file %s successfully." filename))
                                     (format "No such file: %s" filename)))

      (llm-tool-collection-deftool delete-dir
                                   (:category "filesystem" :tags (filesystem editing) :confirm t :include t)
                                   ((dirname "The full dir path to delete"
                                             :type string))
                                   "Deletes directory recursively"
                                   (if (file-exists-p dirname)
                                       (progn (delete-directory dirname t)
                                              (format "Deleted directory %s successfully." dirname))
                                     (format "No such directory %s." dirname)))

      (llm-tool-collection-deftool get-buffer
                                   (:category "filesystem" :tags (filesystem editing) :confirm t :include t)
                                   ((buffer-name "The buffer name" :type string))
                                   "Get a buffer content"
                                   (if (get-buffer buffer-name)
                                       (with-current-buffer buffer-name
                                         (buffer-substring-no-properties (point-min)
                                                                         (point-max)))
                                     (format "buffer %s does not exists" buffer-name)))

      (llm-tool-collection-deftool get-buffer-file-name
                                   (:category "filesystem" :tags (filesystem) :include t)
                                   ((buffer-name "The buffer name" :type string))
                                   "Get the file name of the file visiting buffer."
                                   (if-let (buff (get-buffer buffer-name))
                                       (buffer-file-name buff)
                                     (format "buffer %s does not exists" buffer-name)))

      (llm-tool-collection-deftool summarize-chat-buffer
                                   (:category "buffer" :tags (editing) :confirm t :include t)
                                   ((summary "The context summary" :type string)
                                    (chat-buffer "The buffer name in which the chat takes place" :type string))
                                   "Replace content of the chat buffer with a summary."
                                   (let ((buffer (get-buffer chat-buffer)))
                                     (when buffer
                                       (with-current-buffer buffer
                                         (erase-buffer)
                                         (insert summary)))))

      (llm-tool-collection-deftool get-buffers-name-in-project
                                   (:category "filesystem" :tags (filesystem project) :include t)
                                   ((file-visiting-p "When true, return only the names of file visiting buffers."
                                                     :type boolean
                                                     :optional t)
                                    (project-root-path "The project root path. Accept path with \"~\""
                                                       :type string
                                                       :optional t))
                                   "Get the list of buffers in the current project.
   optionally get only file visiting buffers"
                                   (mapcar #'buffer-name
                                           (-filter (## if file-visiting-p (buffer-file-name %) t)
                                                    (project-buffers (project-current nil project-root-path)))))

      (llm-tool-collection-deftool find-files-by-regex-in-project
                                   (:category "filesystem" :tags (filesystem project search) :include t)
                                   ((regex "Emacs lisp regular expression pattern to match against file names"
                                           :type string))
                                   "Search for files in the current project that match a regex pattern."
                                   (if-let ((proj (project-current nil project-root-path)))
                                       (let* ((default-directory (project-root proj))
                                              (all-files (project-files proj))
                                              (matching-files (seq-filter (lambda (file)
                                                                            (string-match-p regex (file-name-nondirectory file)))
                                                                          all-files)))
                                         (if matching-files
                                             matching-files
                                           "No files matching the pattern were found."))
                                     "No project found. Please open a file within a project first."))

      (llm-tool-collection-deftool get-project-root
                                   (:category "filesystem" :tags (filesystem project) :include t)
                                   ((project-root-path "The project root path. Accept path with \"~\""
                                                       :type string
                                                       :optional t))
                                   "Get the absolute path of the current project's root directory."
                                   (if-let ((proj (project-current nil project-root-path)))
                                       (project-root proj)
                                     "No project found. Please open a file within a project first."))

      (llm-tool-collection-deftool run-rg
                                   (:category "filesystem" :tags (filesystem search project) :include t)
                                   ((pattern "The search pattern to look for in files"
                                             :type string)
                                    (file-pattern "Optional file pattern to filter which files to search (e.g., '*.js', 'src/*.py')"
                                                  :type string
                                                  :optional t)
                                    (project-root-path "The project root path. Accept path with \"~\""
                                                       :type string
                                                       :optional t))
                                   "Run ripgrep (rg) to search for a pattern in the current project.
  optionally filtering by file type."
                                   (if-let* ((proj (project-current nil project-root-path))
                                             (default-directory (project-root proj))
                                             (cmd (if file-pattern
                                                      (format "rg --no-heading --line-number --with-filename %s %s"
                                                              (shell-quote-argument pattern)
                                                              (shell-quote-argument file-pattern))
                                                    (format "rg --no-heading --line-number --with-filename %s"
                                                            (shell-quote-argument pattern))))
                                             (result (shell-command-to-string cmd)))
                                       (if (string-empty-p result)
                                           "No matches found."
                                         result)
                                     "No project found. Please open a file within a project first."))

      (llm-tool-collection-deftool get-flymake-diagnostics
                                   (:category "diagnostics" :tags (diagnostics flymake) :include t)
                                   ((buffer-name "The buffer name to get the diagnostic for."
                                                 :type string))
                                   "Get the content of the flymake diagnostics a specific buffer."
                                   (if-let ((buff (get-buffer buffer-name)))
                                       (with-current-buffer buff
                                         (mapconcat (## format "%s   %s"
                                                        (line-number-at-pos (flymake-diagnostic-beg %))
                                                        (substring-no-properties
                                                         (flymake-diagnostic-message %)))
                                                    (flymake-diagnostics (point-min)
                                                                         (point-max))
                                                    "\n"))
                                     (format "buffer %s does not exists" buffer-name)))

      (defun gptel-eglot--get-definition-context (point)
        "Get definition context for symbol around POINT."
        (when-let* ((symbol-definition (eglot--request
                                        (eglot--current-server-or-lose)
                                        :textDocument/definition
                                        (list :textDocument (eglot--TextDocumentIdentifier)
                                              :position (eglot--pos-to-lsp-position point))))
                    (def-file (plist-get (seq-first symbol-definition) :targetUri))
                    (def-range (plist-get (seq-first symbol-definition) :targetRange)))
          (with-current-buffer (find-file-noselect (eglot-uri-to-path def-file))
            (gptel-eglot--extract-context def-range))))

      (defun gptel-eglot--get-references-context (point)
        "Get references context for symbol around POINT."
        (when-let* ((refs (eglot--request
                           (eglot--current-server-or-lose)
                           :textDocument/references
                           (list :textDocument (eglot--TextDocumentIdentifier)
                                 :position (eglot--pos-to-lsp-position point)
                                 :context '(:includeDeclaration t)))))
          (seq-mapcat (## let ((ref-uri (plist-get % :uri))
                               (ref-range (plist-get % :range)))
                          (with-current-buffer (find-file-noselect (eglot-uri-to-path ref-uri))
                            (format "In %s\nContext:\n%s"
                                    (file-name-nondirectory (buffer-file-name))
                                    (gptel-eglot--extract-context ref-range))))
                      refs
                      'string)))

      (defun gptel-eglot--get-hover-context (point)
        "Get hover documentation context for symbol at POINT."
        (when-let ((hover (eglot--request
                           (eglot--current-server-or-lose)
                           :textDocument/hover
                           (list :textDocument (eglot--TextDocumentIdentifier)
                                 :position (eglot--pos-to-lsp-position point)))))
          (plist-get (plist-get hover :contents) :value)))

      (defun gptel-eglot--extract-context (code-range)
        "Extract CODE-RANGE context."
        (let ((start-point (eglot--lsp-position-to-point (plist-get code-range :start)))
              (end-point (eglot--lsp-position-to-point (plist-get code-range :end))))
          (save-excursion
            (let ((context-start (progn
                                   (goto-char start-point)
                                   (line-beginning-position)))
                  (context-end (progn
                                 (goto-char end-point)
                                 (line-end-position))))
              (buffer-substring-no-properties context-start context-end)))))

      (defun gptel-tool--find-point-in-buffer (symbol &optional line-number)
        "Find point in the current buffer using SYMBOL and maybe LINE-NUMBER."
        (condition-case nil
            (save-excursion
              (goto-char (point-min))
              (when line-number (forward-line (1- line-number)))
              (search-forward symbol (when line-number (line-end-position)) nil))
          (error (error "Could not find symbol %s in buffer %s"
                        symbol
                        (buffer-name (current-buffer))))))

      (llm-tool-collection-deftool eglot-context
                                   (:category "code-intelligence" :tags (eglot lsp code-analysis) :include t)
                                   ((buffer-name "The buffer name in which we want to inspect context around point" :type string)
                                    (symbol "The symbol to examine" :type string)
                                    (line-number "The line number on which the symbol is on"
                                                 :type string
                                                 :optional t))
                                   "Retrieves code context using Eglot (LSP) for the given symbol
  Including definitions, references, and documentation."
                                   (with-current-buffer buffer-name
                                     (if (not (eglot-current-server))
                                         "No Eglot server active for this buffer."
                                       (let ((point (gptel-tool--find-point-in-buffer symbol line-number)))
                                         (format "symbol definition:\n%s\nsymbol references:\n%s\nsymbol info:\n%s"
                                                 (gptel-eglot--get-definition-context point)
                                                 (gptel-eglot--get-references-context point)
                                                 (gptel-eglot--get-hover-context point))))))

      (llm-tool-collection-deftool summarize-chat-buffer
                                   (:category "buffer" :tags (editing) :confirm t :include t)
                                   ((summary "The context summary" :type string)
                                    (chat-buffer "The buffer name in which the chat takes place" :type string))
                                   "Summarize and replace content of the specified chat buffer."
                                   (if-let ((buffer (get-buffer chat-buffer)))
                                       (with-current-buffer buffer
                                         (erase-buffer)
                                         (insert summary))
                                     (format "No such buffer: %s" chat-buffer)))

      ;; Magit tools
      (llm-tool-collection-deftool magit-diff-with-main
                                   (:category "git" :tags (git magit diff) :include t)
                                   ((target-branch "The target branch to diff against (defaults to 'main')"
                                                   :type string
                                                   :optional t))
                                   "Get the diff between current branch and main branch (or specified target branch)"
                                   (condition-case err
                                       (if (not (magit-git-repo-p default-directory))
                                           (format "Not in a git repository. default-directory: %s" default-directory)
                                         (let* ((main-branch (or target-branch "main"))
                                                (current-branch (magit-get-current-branch)))
                                           (if (not current-branch)
                                               "Could not determine current branch"
                                             (if (string= current-branch main-branch)
                                                 (format "Already on %s branch" main-branch)
                                               (let ((diff-output (with-temp-buffer
                                                                    (magit-git-insert "diff" (concat main-branch "...HEAD"))
                                                                    (buffer-string))))
                                                 (if (string-empty-p diff-output)
                                                     (format "No differences found between %s and %s" main-branch current-branch)
                                                   (format "Diff between %s and %s:\n\n%s" main-branch current-branch diff-output)))))))
                                     (error (format "Error getting diff: %s" err))))

      (llm-tool-collection-deftool magit-status
                                   (:category "git" :tags (git magit status) :include t)
                                   ()
                                   "Get the current git status showing staged, unstaged, and untracked files"
                                   (condition-case err
                                       (if (not (magit-git-repo-p default-directory))
                                           "Not in a git repository"
                                         (let ((status-info (with-temp-buffer
                                                              (magit-git-insert "status" "--porcelain")
                                                              (buffer-string))))
                                           (if (string-empty-p status-info)
                                               "Working directory clean"
                                             (format "Git status:\n%s" status-info))))
                                     (error (format "Error getting git status: %s" err))))

      (llm-tool-collection-deftool magit-current-branch
                                   (:category "git" :tags (git magit branch) :include t)
                                   ()
                                   "Get the name of the current git branch"
                                   (condition-case err
                                       (if (not (magit-git-repo-p default-directory))
                                           "Not in a git repository"
                                         (let ((branch (magit-get-current-branch)))
                                           (if branch
                                               (format "Current branch: %s" branch)
                                             "Could not determine current branch (possibly in detached HEAD state)")))
                                     (error (format "Error getting current branch: %s" err))))

      (llm-tool-collection-deftool magit-log
                                   (:category "git" :tags (git magit log) :include t)
                                   ((limit "Number of commits to show (defaults to 10)"
                                           :type number
                                           :optional t))
                                   "Get recent git commits log"
                                   (condition-case err
                                       (if (not (magit-git-repo-p default-directory))
                                           "Not in a git repository"
                                         (let* ((count (or limit 10))
                                                (log-output (with-temp-buffer
                                                              (magit-git-insert "log" "--oneline" (format "-%d" count))
                                                              (buffer-string))))
                                           (if (string-empty-p log-output)
                                               "No commits found"
                                             (format "Recent %d commits:\n%s" count log-output))))
                                     (error (format "Error getting git log: %s" err))))

      (llm-tool-collection-deftool magit-unstaged-changes
                                   (:category "git" :tags (git magit diff) :include t)
                                   ()
                                   "Get the unstaged changes in the working directory"
                                   (condition-case err
                                       (if (not (magit-git-repo-p default-directory))
                                           "Not in a git repository"
                                         (let ((diff-output (with-temp-buffer
                                                              (magit-git-insert "diff")
                                                              (buffer-string))))
                                           (if (string-empty-p diff-output)
                                               "No unstaged changes"
                                             (format "Unstaged changes:\n\n%s" diff-output))))
                                     (error (format "Error getting unstaged changes: %s" err))))

      (llm-tool-collection-deftool magit-staged-changes
                                   (:category "git" :tags (git magit diff) :include t)
                                   ()
                                   "Get the staged changes ready for commit"
                                   (condition-case err
                                       (if (not (magit-git-repo-p default-directory))
                                           "Not in a git repository"
                                         (let ((diff-output (with-temp-buffer
                                                              (magit-git-insert "diff" "--cached")
                                                              (buffer-string))))
                                           (if (string-empty-p diff-output)
                                               "No staged changes"
                                             (format "Staged changes:\n\n%s" diff-output))))
                                     (error (format "Error getting staged changes: %s" err))))

      (llm-tool-collection-deftool summarize-chat-buffer
                                   (:category "context" :tags (editing) :confirm nil :include nil)
                                   ((summary "The context summary." :type string))
                                   "Replace the chat buffer content with a context summary to compact the context."
                                   (when-let ((buffer (current-buffer)))
                                     (message "here")
                                     (with-current-buffer buffer
                                       (erase-buffer)
                                       (insert summary)
                                       (save-buffer)
                                       (goto-char (point-min))
                                       (while (re-search-forward "**?:PROPERTIES:.*\n\\(?:.*\n\\)*?:END:\n" nil t)
                                         (delete-region (match-beginning 0) (match-end 0)))
                                       (save-buffer)
                                       (goto-char (point-max)))))
      ))
#+end_src
** LLM package
#+begin_src elisp
  (use-package llm
    :custom
    (llm-warn-on-nonfree nil))

  (use-package llm-tool-collection
    :ensure (:repo "skissue/llm-tool-collection" :fetcher github :files ("*.el"))
    :config
    (init-llm-tools))
#+end_src
** MCP
#+begin_src elisp
  (use-package mcp
    :ensure (:repo "lizqwerscott/mcp.el" :fetcher github :files ("*.el"))
    :config
    (require 'gptel-integrations)
    (setq mcp-hub-servers
          `(("linear" . (
                         :command "npx"
                         :args ("-y" "mcp-remote" "https://mcp.linear.app/sse")
                         ))
            ("postgres" . (
                           :command  "postgres-mcp"
                           :args ("--access-mode=unrestricted")
                           :env (:DATABASE_URI "postgresql://postgres:grain@localhost:5432/grain"))))))
#+end_src
** Greger
#+begin_src elisp
  (use-package greger
    :ensure (:repo "andreasjansson/greger.el" :fetcher github :files ("*.el"))
    :disabled t
    :config
    (setenv "ANTHROPIC_API_KEY"
            (-some->
                (plist-get (car (auth-source-search :host "claude.ai")) :secret)
              funcall))
    :bind ("C-M-;" . greger))
#+end_src
** Claude Code
#+begin_src elisp
  (use-package claude-code
    :ensure (:type git :host github :repo "stevemolitor/claude-code.el" :branch "main"
                   :files ("*.el" (:exclude "images/*")))
    :init
    (autoload 'claude-code-command-map "claude-code" nil t 'keymap)
    :bind-keymap
    ("C-M-;" . claude-code-command-map)
    :bind (:map claude-code-command-map ("F" . claude-code-send-file))
    :config
    ;; This is required for the `claude-eglot-context'
    (require 'eglot)
    (exec-path-from-shell-initialize)
    (claude-code-mode)
    (defun claude-code-send-file (file-path)
      "Send the specified FILE-PATH to Claude prefixed with `@'.
  FILE-PATH should be an absolute path to the file to send."
      (interactive
       (list (completing-read "File: "
                              (project-files (project-current t)))))
      (let ((command (format "Add the file @%s to the context" file-path)))
        (claude-code--do-send-command command)))

    (defun claude-eglot-context (&optional buffer-name symbol line-number)
      "Get comprehensive eglot context for a symbol in a buffer.
  If BUFFER-NAME is nil, use current buffer.
  If SYMBOL is nil, use symbol at point.
  If LINE-NUMBER is provided, go to that line first.
  Returns definition location, references, type info, and hover information."
      (let ((target-buffer (or buffer-name (current-buffer))))
        (with-current-buffer target-buffer
          (if (not (eglot-current-server))
              "No Eglot server active for this buffer."
            (save-excursion
              (when line-number
                (forward-line (if (stringp line-number)
                               (string-to-number line-number)
                             line-number)))

              ;; Find symbol - either provided, at point, or search for it
              (let ((target-symbol (cond
                                    (symbol
                                     (when (search-forward symbol nil t)
                                       (backward-word))
                                     symbol)
                                    (t (thing-at-point 'symbol)))))

                (if (not target-symbol)
                    "No symbol found at point or provided."

                  (let* ((definitions (condition-case err
                                          (xref-backend-definitions 'eglot target-symbol)
                                        (error (format "Error getting definitions: %s" err))))
                         (references (condition-case err
                                         (xref-backend-references 'eglot target-symbol)
                                       (error (format "Error getting references: %s" err))))
                         (hover-info (condition-case err
                                         (eglot--hover-info (eglot--TextDocumentPositionParams))
                                       (error "No hover info available")))
                         (type-info (condition-case err
                                        (when (eglot-server-capable :typeDefinitionProvider)
                                          (eglot--request (eglot--current-server-or-lose)
                                                          :textDocument/typeDefinition
                                                          (eglot--TextDocumentPositionParams)))
                                      (error nil))))

                    (format "=== Eglot Context for Symbol: %s ===\n\nBuffer: %s\nLine: %s\n\n--- Definitions ---\n%s\n\n--- References ---\n%s\n\n--- Type Information ---\n%s\n\n--- Hover Information ---\n%s"
                            target-symbol
                            (buffer-name target-buffer)
                            (line-number-at-pos)
                            (if (and definitions (listp definitions) (not (stringp definitions)))
                                (mapconcat (lambda (def)
                                             (let ((loc (xref-item-location def)))
                                               (format "  • %s:%s - %s"
                                                       (xref-location-group loc)
                                                       (xref-location-line loc)
                                                       (xref-item-summary def))))
                                           definitions "\n")
                              (if (stringp definitions) definitions "  No definitions found"))

                            (if (and references (listp references) (not (stringp references)))
                                (let ((ref-count (length references)))
                                  (concat (format "  Found %d reference%s:\n" ref-count (if (= ref-count 1) "" "s"))
                                          (mapconcat (lambda (ref)
                                                       (let ((loc (xref-item-location ref)))
                                                         (format "  • %s:%s - %s"
                                                                 (xref-location-group loc)
                                                                 (xref-location-line loc)
                                                                 (xref-item-summary ref))))
                                                     (seq-take references 10) "\n")
                                          (if (> ref-count 10) "\n  ... (showing first 10)" "")))
                              (if (stringp references) references "  No references found"))

                            (if type-info
                                (format "  Type: %s" type-info)
                              "  No type information available")

                            (or hover-info "  No hover information available")))))))))))
#+end_src
* Ediff
#+begin_src elisp
  (defvar ediff-buffer-A)
  (defvar ediff-buffer-B)
  (defvar ediff-buffer-C)
  (defvar ediff-merge-job)
  (defvar ediff-ancestor-buffer)

  (use-package ediff
    :ensure nil
    :custom
    (ediff-keep-variants nil)
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-window-setup-function 'ediff-setup-windows-plain))

  (defvar cc/ediff-revision-session-p nil
    "If t then `cc/ediff-revision-actual' has been called.
  This state variable is used to insert added behavior to the overridden
  function `ediff-janitor'.")

  (defun cc/ediff-revision-from-menu (e)
    "Invoke `ediff-revision' on E with variable `buffer-file-name'."
    (interactive "e")
    (cc/ediff-revision))

  (defun cc/ediff-revision ()
    "Run Ediff on the current `buffer-file-name' provided that it is `vc-registered'.
  This function handles the interactive concerns found in `ediff-revision'.
  This function will also test if a diff should apply to the current buffer."
    (interactive)
    (when (and (bound-and-true-p buffer-file-name)
               (vc-registered (buffer-file-name)))
      (if (and (buffer-modified-p)
               (y-or-n-p (format "Buffer %s is modified.  Save buffer? "
                                 (buffer-name))))
          (save-buffer (current-buffer)))
      (message buffer-file-name)
      (cc/ediff-revision-actual))

    (cond ((not (bound-and-true-p buffer-file-name))
           (message (concat (buffer-name) " is not a file that can be diffed.")))
          ((not (vc-registered buffer-file-name))
           (message (concat buffer-file-name " is not under version control.")))))

  (defun cc/ediff-revision-actual ()
    "Invoke Ediff logic to diff the modified repo file
  to its counterpart in the current branch.
  This function handles the actual diff behavior called by `ediff-revision'."
    (let ((rev1 "")
          (rev2 ""))
      (setq cc/ediff-revision-session-p t)
      (ediff-load-version-control)
      (funcall
       (intern (format "ediff-%S-internal" ediff-version-control-package))
       rev1 rev2 nil)))

  (defun ediff-janitor (ask keep-variants)
    "Kill buffers A, B, and, possibly, C, if these buffers aren't modified.
  In merge jobs, buffer C is not deleted here, but rather according to
  `ediff-quit-merge-hook'.
  ASK non-nil means ask the user whether to keep each unmodified buffer, unless
  KEEP-VARIANTS is non-nil, in which case buffers are never killed.
  A side effect of cleaning up may be that you should be careful when comparing
  the same buffer in two separate Ediff sessions: quitting one of them might
  delete this buffer in another session as well.

  CC MODIFICATION: This method overrides the original Ediff function."
    (let ((ask (if (and (boundp 'cc/ediff-revision-session-p)
                        cc/ediff-revision-session-p)
                   nil
                 ask)))
      (ediff-dispose-of-variant-according-to-user
       ediff-buffer-A 'A ask keep-variants)
      ;; !!!: CC Note: Test global state variable `cc/ediff-revision-session-p' to
      ;; determine if the modified repo file should be kept.
      ;; Guarding in place to hopefully avoid side-effects when `ediff-janitor' is
      ;; called from other Ediff functions. Informal testing has not revealed any
      ;; side-effects but YOLO.
      (if (and (boundp 'cc/ediff-revision-session-p)
               cc/ediff-revision-session-p)
          (ediff-dispose-of-variant-according-to-user
           ;; CC Note: keep-variants argument is hard-coded to t to keep
           ;; buffer holding modified repo file around.
           ediff-buffer-B 'B t t)
        (ediff-dispose-of-variant-according-to-user
         ediff-buffer-B 'B ask keep-variants))
      (if ediff-merge-job  ; don't del buf C if merging--del ancestor buf instead
          (ediff-dispose-of-variant-according-to-user
           ediff-ancestor-buffer 'Ancestor ask keep-variants)
        (ediff-dispose-of-variant-according-to-user
         ediff-buffer-C 'C ask keep-variants))
      ;; CC Note: Reset global state variable `cc/ediff-revision-session-p'.
      (if (and (boundp 'cc/ediff-revision-session-p)
               cc/ediff-revision-session-p)
          (setq cc/ediff-revision-session-p nil))))

  (defun cc/stash-window-configuration-for-ediff ()
    "Store window configuration to register 🧊.
  Use of emoji is to avoid potential use of keyboard character to reference
  the register."
    (window-configuration-to-register ?🧊))

  (defun cc/restore-window-configuration-for-ediff ()
    "Restore window configuration from register 🧊.
  Use of emoji is to avoid potential use of keyboard character to reference
  the register."
    (jump-to-register ?🧊))

  (add-hook 'ediff-before-setup-hook #'cc/stash-window-configuration-for-ediff)
  ;; !!!: CC Note: Why this is not `ediff-quit-hook' I do not know. But this works
  ;; for cleaning up ancillary buffers on quitting an Ediff session.
  (add-hook 'ediff-after-quit-hook-internal #'cc/restore-window-configuration-for-ediff)
#+end_src

* Scratch Pop
#+begin_src elisp
  (use-package scratch-pop
    :bind ("C-c r" . scratch-pop)
    :config
    (add-hook 'kill-emacs-hook 'scratch-pop-backup-scratches)
    (scratch-pop-restore-scratches 3)
    :custom
    (scratch-pop-initial-major-mode 'fundamental-mode)
    (scratch-pop-backup-directory (concat user-emacs-directory "scratch-pop")))
#+end_src
* Consult
#+begin_src elisp
  (defvar bob/consult--source-project-buffer
    `( :name     "Project Buffer"
       :narrow   ?b
       :category buffer
       :face     consult-buffer
       :history  buffer-name-history
       :state    ,#'consult--buffer-state
       :enabled  ,(lambda () consult-project-function)
       :items
       ,(lambda ()
          (when-let (root (consult--project-root))
            (consult--buffer-query :sort 'visibility
                                   :directory root
                                   :as #'consult--buffer-pair
                                   :predicate #'buffer-file-name))))
    "Project buffer source for `consult-buffer'.")
  (use-package consult
    :ensure t
    :init
    (setq consult--tofu-char #x100000
          consult--tofu-range #x00fffe)
    :custom
    (consult-project-buffer-sources
     '(bob/consult--source-project-buffer
       consult--source-project-recent-file
       consult--source-project-root))
    :bind
    ("M-i" . consult-imenu)
    ("C-x b" . consult-buffer)
    ("M-g r" . consult-ripgrep)
    ("M-y" . consult-yank-from-kill-ring))
#+end_src

* Casual packages
#+begin_src elisp
  (use-package casual)
#+end_src
** Re builder
#+begin_src elisp
  (use-package re-builder
    :ensure nil
    :bind
    (:map reb-mode-map ("M-i" . casual-re-builder-tmenu))
    (:map reb-lisp-mode-map ("M-i" . casual-re-builder-tmenu)))
#+end_src

** Calc
#+begin_src elisp
  (use-package calc
    :ensure nil
    :bind
    (:map calc-mode-map ("M-i" . casual-calc-tmenu)))
#+end_src

* Dired
#+begin_src elisp
  (use-package dired
    :commands dired
    :ensure nil
    :custom
    (dired-auto-revert-buffer t)
    (dired-listing-switches "-lah --group-directories-first")
    (dired-use-ls-dired t)
    (delete-by-moving-to-trash t)
    (dired-dwim-target t)
    :config
    (setq insert-directory-program
          (s-replace "\n" "" (s-replace "//" "/" (shell-command-to-string "which gls"))))
    :hook
    (dired-mode . (lambda () (dired-hide-details-mode 1)))
    :bind
    (:map dired-mode-map ("M-i" . casual-dired-tmenu)))

  (use-package dired-sidebar
    :commands (dired-sidebar-toggle-sidebar dired-sidebar-toggle-with-current-directory)
    :after (dired)
    :bind
    ;; "C-u C-x D"
    ("C-x C-d" . dired-sidebar-toggle-sidebar)
    :custom
    (dired-sidebar-width 40)
    (dired-sidebar-subtree-line-prefix "  ")
    (dired-sidebar-theme 'vscode)
    (dired-sidebar-use-term-integration t)
    (dired-sidebar-use-custom-font t)
    :hook
    (dired-sidebar-mode . (lambda ()
                            (unless (file-remote-p default-directory)
                              (auto-revert-mode))))
    :custom-face
    (dired-sidebar-face ((t (:family "Menlo"))))
    ;; :config
    ;; (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
    ;; (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
    )

  (use-package dired-subtree
    :after (dired)
    :bind (:map dired-mode-map
                ("TAB" . dired-subtree-toggle)))

  (use-package all-the-icons-dired
    :if (window-system)
    :custom
    (all-the-icons-dired-monochrome nil)
    :after (dired)
    :config
    (add-to-list 'all-the-icons-extension-icon-alist
                 '("roc" all-the-icons-fileicon "elm" :face all-the-icons-blue))
    (add-to-list 'all-the-icons-mode-icon-alist
                 '(roc-mode all-the-icons-fileicon "elm" :face all-the-icons-blue))
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package diredfl
    :hook
    (dired-mode . diredfl-mode))
#+end_src

* Save History
#+begin_src elisp
  (use-package savehist
    :ensure nil
    :init
    (setq savehist-file (locate-user-emacs-file "savehist"))
    (setq history-length 10000)
    (setq history-delete-duplicates t)
    (setq savehist-save-minibuffer-history t)
    (savehist-mode))

  (use-package recentf-mode
    :ensure nil
    :init (recentf-mode))
#+end_src

* Markdown
** markdown-mode
#+begin_src elisp
  (use-package markdown-mode
    :custom (markdown-fontify-code-blocks-natively t))
#+end_src
** edit-indirect (a markdown mode dependency for editing code blocks)
#+begin_src elisp
  (use-package edit-indirect)
#+end_src

* Org Mode
** Org mode configuration
#+begin_src elisp
  (use-package ob-js
    :ensure nil
    :custom (org-babel-js-cmd "node"))
  (use-package ob-typescript)

  (use-package org
    :commands (org-agenda)
    :custom
    (org-directory (expand-file-name "~/Library/Mobile Documents/iCloud~com~appsonthemove~beorg/Documents/"))
    (org-babel-python-command "python3")
    (org-hide-emphasis-markers t)
    (org-pretty-entities nil)
    (org-export-with-toc nil)
    (org-confirm-babel-evaluate nil)
    (org-loop-over-headlines-in-active-region t)
    (calendar-longitude 32.085300)
    (calendar-latitude 34.781769)
    (org-enforce-todo-dependencies t)
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c)")))
    (org-stuck-projects
     '("+LEVEL=1+PROJECT" ("NEXT" "WAITING") ("@IGNORE" "@REMINDER") ""))
    (org-tags-exclude-from-inheritance '("project"))
    (org-capture-templates
     `(("t" "entry" entry (file ,(concat org-directory "20240104T120451--inbox__project.org")) "* %?\n  %i")))
    (org-refile-targets '((org-agenda-files :maxlevel . 3)))
    (org-refile-use-outline-path 'file)
    (org-deadline-warning-days 1)
    :config
    (defun bob/babel-ansi ()
      (when-let ((beg (org-babel-where-is-src-block-result nil nil)))
        (save-excursion
          (goto-char beg)
          (when (looking-at org-babel-result-regexp)
            (let ((end (org-babel-result-end))
                  (ansi-color-context-region nil))
              (ansi-color-apply-on-region beg end))))))
    (setq org-babel-lisp-eval-fn 'sly-eval)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (js . t)
       (shell . t)
       (python . t)
       (lisp . t)
       (typescript . t)))
    (add-to-list 'org-src-lang-modes '("ts" . typescript))
    :hook
    (org-babel-after-execute . #'bob/babel-ansi)
    (org-mode . (lambda () (org-superstar-mode 1)))
    (org-mode . (lambda () (visual-line-mode 1)))
    (org-archive . org-save-all-org-buffers)
    (org-after-refile-insert . org-save-all-org-buffers)
    :bind
    ("C-c a" . org-agenda)
    ("C-c l" . org-store-link)
    ("C-c c" . org-capture)
    (:map org-mode-map
          ("M-p" . org-metaup)
          ("M-n" . org-metadown)
          ("C-c S" . org-save-all-org-buffers)
          ("M-," . org-mark-ring-goto)
          ("M-F" . org-shiftright)
          ("M-B" . org-shiftleft)
          ("C-c n R" . org-refile))
    (:map org-read-date-minibuffer-local-map
          ("M-f" . (lambda ()
                     (interactive (org-eval-in-calendar '(calendar-forward-day 1)))))
          ("M-b" . (lambda ()
                     (interactive (org-eval-in-calendar '(calendar-backward-day 1)))))
          ("M-p" . (lambda ()
                     (interactive (org-eval-in-calendar '(calendar-backward-week 1)))))
          ("M-n" . (lambda ()
                     (interactive (org-eval-in-calendar '(calendar-forward-week 1)))))))
#+end_src

** Agenda
#+begin_src elisp
  (use-package org-agenda
    :commands (org-agenda)
    :after (org)
    :custom
    (org-agenda-span 1)
    (org-agenda-files `(,(format "%sjournal" org-directory)
                        "beorg.org"
                        "linear.org"
                        "20240104T120451--inbox__project.org"
                        "20240103T130349--reminders__project.org"
                        "20240103T130420--tasks__project.org"))
    (org-agenda-custom-commands
     '(("b" tags "+OngoingBugs")
       ("n" "Todo next" ((todo "NEXT")))))
    :bind
    (:map org-agenda-mode-map
          ("M-F" . org-agenda-do-date-later)
          ("M-B" . org-agenda-do-date-earlier)
          ("C-c C-g" . linear/update-linear-issues))
    :ensure nil
    :config
    (org-super-agenda-mode 1))

  (use-package org-super-agenda
    :config
    (defun bob/org-super-agenda-custom-header-format (header)
      (progn (string-match ".+?:[[:space:]]\\(.+?$\\)"
                           header)
             (match-string 1 header)))
    (setq org-super-agenda-groups
          '((:name "Reminders"
                   :file-path "reminders"
                   :order 4)
            (:name "Calendar"
                   :discard (:file-path "reminders")
                   :discard (:tag "chennofar@gmailcom")
                   :time-grid t
                   :order 2)
            (:name "Today Journal"
                   :file-path "journal"
                   :order 1.1
                   :transformer bob/org-super-agenda-custom-header-format)
            (:name "Do Next"
                   :todo "NEXT"
                   :order 2)
            (:name "Do Later"
                   :todo "TODO"
                   :order 3)
            (:name "Waiting"
                   :todo "WAITING"
                   :order 4)))
    (org-super-agenda-mode 1))
#+end_src

** Org Superstar
#+begin_src elisp
  (use-package org-superstar
    :after org
    :hook (org-mode . org-superstar-mode)
    :config
    (set-face-attribute 'org-superstar-header-bullet nil :inherit 'fixed-pitched :height 180)
    :custom
    ;; set the leading bullet to be a space. For alignment purposes I use an em-quad space (U+2001)
    (org-superstar-headline-bullets-list '("❍"  9673 9675 10040 10047))
    (org-superstar-todo-bullet-alist '(("DONE" . ?✔)
                                       ("NEXT" . ?☞)
                                       ("TODO" . ?⌖)
                                       ("ISSUE" . ?)
                                       ("BRANCH" . ?)
                                       ("FORK" . ?)
                                       ("MR" . ?)
                                       ("MERGED" . ?)
                                       ("GITHUB" . ?A)
                                       ("WRITING" . ?✍)
                                       ("WRITE" . ?✍)
                                       ))
    (org-superstar-special-todo-items t)
    (org-superstar-leading-bullet " ")
    (org-superstar-todo-bullet-face-alist tb/org-todo-bullet-faces)
    (org-hide-leading-stars nil))
#+end_src

* Denote
#+begin_src elisp
  (use-package denote
    :commands (denote denote-mode denote-open-or-create denote-directory-files)
    :custom
    ;; (denote-open-or-create-fn 'consult-file)
    (denote-directory org-directory)
    (denote-date-prompt-use-org-read-date t)
    (denote-prompts '(title keywords file-type))
    :bind
    ("C-c d d" . denote-open-or-create))

  (use-package denote-journal
    :ensure (:repo "protesilaos/denote-journal" :fetcher github :files ("*.el" "*.texi"))
    :config
    (add-hook 'calendar-mode-hook #'denote-journal-calendar-mode)
    :bind ("C-c d t" . denote-journal-new-or-existing-entry))
#+end_src

* Verb: Rest api interface
#+begin_src elisp
  (use-package verb
    :after (org)
    :config
    (defun parse-verb-response-to-alist ()
      (when verb-parse-json-to-alist
        (let ((response (slot-value verb-http-response :body)))
          (progn
            (erase-buffer)
            (when response
              (insert (condition-case nil
                          (pp-to-string (json-parse-string response
                                                           :object-type 'alist
                                                           :array-type 'list
                                                           :null-object 'nil))
                        (json-parse-error response))))
            (verb-response-body-mode +1)))))
    (setq verb-parse-json-to-alist nil)
    (setq verb-post-response-hook 'parse-verb-response-to-alist)
    (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+end_src
* Git
** Ghub
#+begin_src elisp
  (use-package ghub
    :commands (ghub-post))
#+end_src

** Magit
#+begin_src elisp
  (use-package magit
    :custom (magit-process-apply-ansi-colors 'filter)
    :config
    (defun bob/create-github-repo ()
      "Create a new Github repo using the Github API."
      (interactive)
      (let ((repo-name (read-string "Repo name: " (get-dir-name (project-root (project-current)))))
            (repo-description (read-string "Repo description: "))
            (repo-homepage (read-string "Repo homepage: "))
            (is-repo-private (yes-or-no-p "Is Repo private: "))
            (repo-is_template (yes-or-no-p "Is Repo is_template: "))
            (current-branch (magit-get-current-branch)))
        (ghub-post "/user/repos" (list  :name repo-name
                                        :description repo-description
                                        :homepage repo-homepage
                                        :private is-repo-private
                                        :is_template repo-is_template))
        (magit-remote-add "origin" (format "git@github.com:bobrowadam/%s.git" repo-name))
        (magit-run-git-async "push"
                             "-u"
                             "origin"
                             (format "refs/heads/%s:refs/heads/%s"
                                     current-branch
                                     current-branch))))
    (defun bob/remove-project-roots-advice (orig-fun worktree)
      "Remove project roots when deleting git worktrees."
      (project-forget-projects-under worktree)
      (funcall orig-fun worktree))

    (defun bob/is-grain-project (path)
      (let ((default-directory path))
        (equal (bob/npm--project-name) "grain")))

    (defun bob/setup-grain-project-for-worktree (path)
      (message "Setup grain worktree in %s path" path)
      (make-symbolic-link "~/source/grain/.claude"
                          (format "%s/.claude" path))
      (make-symbolic-link "~/source/grain/CLAUDE.md"
                          (format "%s/CLAUDE.md" path))
      (copy-file "~/source/grain/.env"
                 (format "%s/.env" path))
      (copy-file "~/source/grain/build.number"
                 (format "%s/build.number" path)))

    (defun bob/setup-worktree-checkout (orig-fun path worktree)
      (funcall orig-fun path worktree)
      (message "checkout worktree %s in path %s" worktree path)
      (when (bob/is-grain-project path)
        (bob/setup-grain-project-for-worktree path)))

    (defun bob/setup-worktree-branch (orig-fun path worktree starting-point)
      (funcall orig-fun path worktree starting-point)
      (message (format "created worktree %s in path %s starting at %s" worktree path starting-point))
      (when (bob/is-grain-project path)
        (bob/setup-grain-project-for-worktree path)))

    (advice-add 'magit-worktree-delete :around #'bob/remove-project-roots-advice)
    (advice-add 'magit-worktree-checkout :around #'bob/setup-worktree-checkout)
    (advice-add 'magit-worktree-branch :around #'bob/setup-worktree-branch)
    (magit-wip-mode 1)
    (transient-append-suffix 'magit-file-dispatch
      "p"
      '("P" "Push" magit-push))
    (transient-append-suffix 'magit-file-dispatch
      "P"
      '("F" "Pull" magit-pull))
    (defun bob/magit-commit-message (message)
      (interactive "sCommit message: ")
      (magit-commit-create `("-am" ,message)))
    (transient-append-suffix 'magit-commit
      "c"
      '("m" "Quick commit using minibuffer for commit message." bob/magit-commit-message))
    (defun bob/magit-buffers ()
      "Jump to a magit buffer."
      (interactive)
      (if-let* ((magit-buffers
                 (bob/drop-buffer
                  (set-last-magit-buffer-as-first
                   (seq-filter
                    (lambda (b) (or (equal (with-current-buffer b major-mode) 'magit-status-mode)))
                    (mapcar (function buffer-name) (buffer-list))))))
                (magit-buffer (completing-read "Magit: " magit-buffers)))
          (progn
            (setq bob/last-magit-buffer magit-buffer)
            (switch-to-buffer magit-buffer))
        (message "No Magit buffers exists")))
    (defun bob/magit-fetch-and-rebase ()
      "Fetch \"origin/main and\" rebase current branch onto \"main\"."
      (interactive)
      (message "Running 'git rebase origin/main'")
      (magit-run-git "fetch" "origin" "main")
      (magit-rebase-branch "origin/main" nil))
    (transient-append-suffix 'magit-rebase
      "f"
      '("F" "Fetch & Rebase" bob/magit-fetch-and-rebase)))
#+end_src
** Forge
#+begin_src elisp
  (use-package forge
    :after magit
    :custom
    (forge-status-buffer-default-topic-filters
     (forge--topics-spec
      :type 'topic :active nil :state 'open :order 'newest
      :author "bobrowadam"
      :limit 10))
    :init (setq forge-bug-reference-hooks nil))
#+end_src
** Pr Reviews
#+begin_src elisp
  (use-package pr-review)
  (use-package github-review)
#+end_src
** Git Time Machinie
#+begin_src elisp
  (use-package git-timemachine
    :ensure t)
#+end_src
* Diff
#+begin_src elisp
  (use-package diff-mode
    :ensure nil
    :bind (:map diff-mode-shared-map
                ("K" . #'bob/diff-kill-other-hunks))
    :config
    (defun bob/diff-kill-other-hunks ()
      "Keep only the chunk around point."
      (interactive)
      (let ((current-hunk (diff-bounds-of-hunk)))
        (save-excursion
          (goto-char (point-min))
          (diff--iterate-hunks (point-max)
                               (𝝺 unless (equal (list %1 %2)
                                                current-hunk)
                                  (diff-hunk-kill)))
          (unless (equal (point-max)
                         (cadr (diff-bounds-of-hunk)))
            (bob/diff-kill-other-hunks))))))

  (use-package diff-hl
    :hook
    (prog-mode . #'turn-on-diff-hl-mode)
    (vc-dir-mode . (lambda () (diff-hl-dir-mode 1)))
    (dired-mode . diff-hl-dired-mode)
    (magit-post-refresh . #'diff-hl-magit-post-refresh)
    :bind (:map diff-hl-mode-map ("C-x v A" . diff-hl-set-reference-rev)))

  (use-package abridge-diff
    :demand t
    :after magit
    :config (abridge-diff-mode 1))
#+end_src

* Handle parentesis editing
** Paredit
#+begin_src elisp
  (use-package paredit
    :hook
    (emacs-lisp-mode lisp-mode lisp-data-mode))
#+end_src
** Smart arens
#+begin_src elisp
  (use-package smartparens
    :config
    (setq sp-ignore-modes-list
          '(minibuffer-inactive-mode emacs-lisp-mode eval-expression-minibuffer-setup common-lisp-mode lisp-mode sly-mode))
    (require 'smartparens-config)
    (sp-local-pair 'typescript-mode "<" ">" :trigger-wrap "<")
    (sp-local-pair 'typescript-ts-mode "<" ">" :trigger-wrap "<")
    :hook
    (typescript-ts-mode tsx-ts-mode c-ts-mode js-ts-mode text-mode comint-mode minibuffer-mode)
    :bind (:map smartparens-mode-map
                ("M-(" . sp-wrap-round)
                ("M-s" . sp-unwrap-sexp)
                ("C-)" . sp-forward-slurp-sexp)
                ("C-}" . sp-forward-barf-sexp)
                ("C-{" . sp-backward-barf-sexp)
                ("C-(" . sp-backward-slurp-sexp)
                ("C-'" . sp-rewrap-sexp)
                ("M-S" . sp-split-sexp)
                ("M-J" . sp-join-sexp)
                ("M-W" . sp-copy-sexp)))
#+end_src

* Auto Completion and Minibuffer actions
** Vertico
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode))
#+end_src
** HotFuzz
#+begin_src elisp
  (use-package hotfuzz
    :demand t
    :ensure ( :package "hotfuzz"
              ;; Inherited from elpaca-order-functions.
              :depth treeless
              :inherit t
              :protocol https
              ;; Inherited from elpaca-menu-item.
              :files (:defaults)
              :fetcher github
              :repo "axelf4/hotfuzz")
    :config
    ;; https://github.com/axelf4/hotfuzz/issues/1#issuecomment-1907058175:
    (defvar +hotfuzz--is-empty nil)
    (defun +hotfuzz-all-completions--enable-history-a (orig content &rest args)
      "Set a variable needed for showing most recent entries."
      (setq +hotfuzz--is-empty (string-empty-p content))
      (apply orig content args))
    (advice-add #'hotfuzz-all-completions
                :around #'+hotfuzz-all-completions--enable-history-a)
    (defun +hotfuzz--adjust-metadata--enable-history-a (orig metadata)
      "Enable showing most recent entries for empty input."
      (if +hotfuzz--is-empty
          metadata
        (funcall orig metadata)))
    (advice-add #'hotfuzz--adjust-metadata
                :around #'+hotfuzz--adjust-metadata--enable-history-a))
#+end_src
** Orderless
#+begin_src elisp
  (use-package orderless
    :demand t
    :init
    (setq completion-ignore-case t)
    (setq read-file-name-completion-ignore-case nil)
    (setq orderless-component-separator " +")
    (setq orderless-matching-styles
          '(orderless-literal orderless-prefixes orderless-flex))
    (setq completion-category-defaults nil
          completion-category-overrides '((file (styles basic partial-completion))))
    (setq completion-styles '(hotfuzz orderless basic)))
#+end_src
** Embark
#+begin_src elisp
  (use-package embark
    :bind
    (("C-." . embark-act)
     ("C-h B" . embark-bindings)))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
** Marginalia
#+begin_src elisp
  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode 1))
#+end_src
** Corfu
#+begin_src elisp
  (use-package corfu
    :custom
    (tab-always-indent 'complete)
    (completion-cycle-threshold 1)
    (corfu-auto-delay 0.06)
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                 ;; Enable auto completion
    (corfu-separator ?\s)          ;; Orderless field separator
    (corfu-quit-at-boundary 'separator)
    (corfu-quit-no-match 'separator)
    (corfu-preview-current t)    ;; Disable current candidate preview
    (corfu-preselect-first nil)    ;; Disable candidate preselection
    (corfu-on-exact-match 'insert)     ;; Configure handling of exact matches
    (corfu-echo-documentation t) ;; Disable documentation in the echo area
    (corfu-scroll-margin 8)        ;; Use scroll margin
    (corfu-auto-prefix 1)
    :init
    (global-corfu-mode))

  (use-package cape
    :init
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-rfc1345)
    (add-hook 'completion-at-point-functions #'cape-history)
    (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src

* Programming
#+begin_src elisp
  (use-package prog-mode
    :ensure nil
    :hook
    (prog-mode . (lambda () (display-line-numbers-mode 1))))

  (use-package display-line-numbers
    :ensure nil
    :hook (prog-mode))

  (use-package breadcrumb
    :hook (prog-mode))
#+end_src
** FNM - node version manager (like nvm replacment)
#+begin_src elisp
  (use-package fnm
    :demand t
    :ensure
    (:fetcher github
              :repo "bobrowadam/fnm.el"
              :branch "main"
              :files ("fnm.el")))
#+end_src
** Project
#+begin_src elisp
  (use-package project
    :ensure nil
    :custom
    (project-list-file (format "%sprojects" user-emacs-directory))
    (project-vc-extra-root-markers '("package.json"))
    :config
    (require 'project-extras)
    (setq project-switch-commands
          '((project-find-file "Find file")
            (project-dired "Root Directory" "d")
            (eat-project "Eat" "s")
            (bob/eat-top-project "Eat Top" "S")
            (magit-project-status "Magit" "g")
            (consult-ripgrep "RipGrep" "r")
            (consult-project-buffer "Buffers" "b")
            (browse-current-project "Browse" "B")))
    (unless (project-known-project-roots)
      (message "No project file found, indexing projects")
      (progn
        (project-remember-projects-under user-emacs-directory)
        (project-remember-projects-under "~/source/grain/apps/backend/" t)
        (project-remember-projects-under "~/source/grain/packages/" t)))
    :bind
    ("C-x p C-m"  . project-dired)
    ("C-x p b" . consult-project-buffer)
    ("C-x p w" . bob/switch-to-open-project-buffer))
#+end_src
** eslint
#+begin_src elisp
  (defun set-eslint-executable-name ()
    (setq flymake-eslint-executable-name
          (if-let ((local-eslint-path (locate-dominating-file "" "node_modules/.bin/eslint")))
              (format "%snode_modules/.bin/eslint" local-eslint-path)
            "eslint")))
#+end_src
** Flymake
#+begin_src elisp
  (use-package flymake
    :config
    (setq elisp-flymake-byte-compile-load-path load-path)
    :bind
    (:map flymake-mode-map
          ("C-c ! l" . flymake-show-buffer-diagnostics)
          ("C-c ! n" . flymake-goto-next-error)
          ("C-c ! p" . flymake-goto-prev-error)))

  (defun bob/elisp-flymake-setup ()
    "Setup flymake in `emacs-lisp-mode'."
    ;; (add-hook 'flymake-diagnostic-functions #'bob/elisp-function-naming-convention nil t)
    (unless (seq-contains-p '("init.el" "init-literate.el")
                            (-some-> (buffer-file-name) (file-name-nondirectory)))
      (flymake-mode t)))
#+end_src
** Eslint
#+begin_src elisp
  (use-package flymake-eslint
    :after flymake
    :hook
    (typescript-ts-mode . flymake-eslint-enable)
    (typescript-js-mode . flymake-eslint-enable))
#+end_src
** Prettier
#+begin_src elisp
  (use-package prettier
    :hook (typescript-ts-mode tsx-ts-mode js2-mode js-ts-mode))

  (use-package eglot-booster
    :ensure ( :package "eglot-booster"
              :protocol https
              :files ("eglot-booster.el")
              :fetcher github
              :repo "jdtsmith/eglot-booster"))
#+end_src
** Eldoc
#+begin_src elisp
  (use-package eldoc-box
    :after eglot
    :bind (:map eglot-mode-map ("C->" . eldoc-box-help-at-point)))
#+end_src
** Eglot
#+begin_src elisp
  (use-package eglot
    ;; :ensure (:wait t)
    :after (fnm exec-path-from-shell)
    :custom-face (eglot-highlight-symbol-face ((t (:inherit bold :underline t :slant italic))))
    :commands (eglot eglot-ensure eglot-shutdown-all)
    :custom
    (eglot-events-buffer-config '(:size 0 :format full))
    (eglot-sync-connect 0)
    :config
    (exec-path-from-shell-initialize)
    (eglot-booster-mode)
    (add-to-list 'eglot-server-programs
                 `((js2-mode js-mode js-ts-mode typescript-ts-mode typescript-mode tsx-ts-mode)
                   . ("typescript-language-server" "--stdio")))
    (add-to-list 'eglot-server-programs
                 `((json-mode)
                   . ("vscode-json-languageserver" "--stdio")))
    (add-to-list 'eglot-server-programs
                 '(sql-mode . (eglot-sqls "sqls" "-config" ".sqls-config")))
    (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
    (add-to-list 'eglot-server-programs '((roc-ts-mode) "roc_language_server"))
    (add-to-list 'eglot-server-programs '((zig-mode) "zls"))
    (unless (executable-find "pyright-langserver")
      (progn
        (print "Installing pyright-langserver for python eglot support")
        (async-shell-command "npm install -g pyright"
                             "*pyright-installation-stdout*"
                             "*pyright-installation-error*")))
    (add-to-list 'eglot-server-programs '((python-ts-mode) . ("pyright-langserver" "--stdio")))

    (cl-defmethod project-root ((project (head eglot-project)))
      (cdr project))
    :bind
    (:map eglot-mode-map
          ("C->" . eldoc-print-current-symbol-info)
          ("C-c C-f" . eglot-format)
          ("C-c C-n" . eglot-rename)
          ("M-n" . forward-paragraph)
          ("M-p" . backward-paragraph)
          ("M-." . xref-find-definitions)
          ("M-?" . xref-find-references)
          ("C-<" . eglot-find-typeDefinition)
          ("C-c C-a" . eglot-code-actions))
    :hook
    ((python-ts-mode js2-mode c++-mode c++-ts-mode c-mode c-ts-mode typescript-ts-mode tsx-ts-mode python-mode rust-mode json-mode sql-mode haskell-mode roc-ts-mode) . eglot-ensure)
    (eglot-managed-mode .  (lambda ()
                             (when (or (eq (derived-mode-p major-mode) 'typescript-ts-mode)
                                       (eq (derived-mode-p major-mode) 'js-ts-mode))
                               (set-eslint-executable-name)
                               (flymake-eslint-enable)))))

#+end_src
** Dape
#+begin_src elisp
  (use-package dape
    :bind
    ("C-x C-a d" . dape)
    ("C-x C-a b" . dape-breakpoint-toggle)
    :custom
    (dape-info-buffer-window-groups '((dape-info-scope-mode dape-info-watch-mode)))
    :config
    (defun dape-set-available-port (config)
      (when-let ((available-port (pick-port-for-inspected-service)))
        (plist-put config :port (string-to-number available-port)))
      config)
    (add-to-list 'dape-default-config-functions 'dape-set-available-port)
    (setq dape-inlay-hints nil)
    (add-to-list 'dape-configs
                 `(vscode-ts-js-attach
                   modes (js-mode js-ts-mode typescript-ts-mode)
                   host "localhost"
                   port 8123
                   command "node"
                   command-cwd "~/.emacs.d/debug-adapters/js-debug"
                   command-args ("src/dapDebugServer.js")
                   :sourceMaps t
                   :resolveSourceMapLocations ["**/dist/**/*"]
                   :cwd dape-cwd-fn
                   :autoAttachChildProcesses t
                   :type "pwa-node"
                   :request "attach"
                   :outputCapture "console"
                   :sourceMapRenames t
                   :autoAttachChildProcesses t
                   :console "internalConsole"
                   :killBehavior "forceful"))

    (add-to-list 'dape-configs
                 `(ts-node-attach
                   modes (js-mode js-ts-mode typescript-ts-mode)
                   host "localhost"
                   port 8123
                   command "node"
                   command-cwd "~/.emacs.d/debug-adapters/js-debug"
                   command-args ("src/dapDebugServer.js")
                   :sourceMaps t
                   :resolveSourceMapLocations ["**","!**/node_modules/**"]
                   :cwd dape-cwd-fn
                   :autoAttachChildProcesses t
                   :type "pwa-node"
                   :request "attach"
                   :outputCapture "console"
                   :sourceMapRenames t
                   :autoAttachChildProcesses t
                   :console "internalConsole"
                   :killBehavior "forceful"))
    ;; To not display info and/or buffers on startup
    (remove-hook 'dape-on-start-hooks 'dape-info)
    (remove-hook 'dape-on-start-hooks 'dape-repl)

    ;; Use n for next etc. in REPL
    (setq dape-repl-use-shorthand t)

    ;; Kill compile buffer on build success
    (add-hook 'dape-compile-compile-hooks 'kill-buffer)
    :hook (dape-active-mode . repeat-mode))
#+end_src
** Code Comments
#+begin_src elisp
  (use-package comment-tags
    :custom
    (comment-tags-keywords '("TODO"
                             "FIXME"
                             "BUG"
                             "HACK"
                             "INFO"
                             "DONE"))
    (comment-tags-require-colon t)
    :hook (prog-mode))
#+end_src
** Jest
#+begin_src elisp
  (use-package jest-ts-mode
    :ensure (:package "jest-ts-mode"
                      :fetcher github
                      :branch "main"
                      :repo "bobrowadam/jest-ts-mode"
                      :files ("jest-ts-mode.el"))
    :hook (typescript-ts-mode)
    :custom
    (jest-ts/environment-variables '(("IN_MEMORY_DB" . "true")))
    (jest-ts/inspect-port #'get-next-available-inspect-port))

#+end_src
** Typescript
#+begin_src elisp
  (use-package typescript-mode
    :mode (("\\.ts\\'" . typescript-ts-mode) ("\\.tsx\\'" . tsx-ts-mode))
    :bind
    ("C-c C-b" . npm-run-build)
    :config
    (fnm-use)
    (setq typescript-ts-mode-indent-offset 2))

  (use-package jtsx
    :mode (("\\.jsx?\\'" . jtsx-jsx-mode)
           ("\\.tsx\\'" . jtsx-tsx-mode))
    :commands jtsx-install-treesit-language
    :hook ((jtsx-jsx-mode . hs-minor-mode)
           (jtsx-tsx-mode . hs-minor-mode)
           (jtsx-typescript-mode . hs-minor-mode))
    :custom
    ;; Optional customizations
    (js-indent-level 2)
    (typescript-ts-mode-indent-offset 2)
    ;; (jtsx-switch-indent-offset 0)
    (jtsx-indent-statement-block-regarding-standalone-parent nil)
    (jtsx-jsx-element-move-allow-step-out t)
    (jtsx-enable-jsx-electric-closing-element t)
    (jtsx-enable-electric-open-newline-between-jsx-element-tags t)
    (jtsx-enable-jsx-element-tags-auto-sync nil)
    (jtsx-enable-all-syntax-highlighting-features t)
    :config
    (defun jtsx-bind-keys-to-mode-map (mode-map)
      "Bind keys to MODE-MAP."
      (define-key mode-map (kbd "C-c C-j") 'jtsx-jump-jsx-element-tag-dwim)
      (define-key mode-map (kbd "C-c j o") 'jtsx-jump-jsx-opening-tag)
      (define-key mode-map (kbd "C-c j c") 'jtsx-jump-jsx-closing-tag)
      (define-key mode-map (kbd "C-c j r") 'jtsx-rename-jsx-element)
      (define-key mode-map (kbd "C-c j w") 'jtsx-wrap-in-jsx-element)
      (define-key mode-map (kbd "C-c j u") 'jtsx-unwrap-jsx)
      (define-key mode-map (kbd "C-c j d n") 'jtsx-delete-jsx-node)
      (define-key mode-map (kbd "C-c j d a") 'jtsx-delete-jsx-attribute)
      (define-key mode-map (kbd "C-c j t") 'jtsx-toggle-jsx-attributes-orientation)
      (define-key mode-map (kbd "C-c j h") 'jtsx-rearrange-jsx-attributes-horizontally)
      (define-key mode-map (kbd "C-c j v") 'jtsx-rearrange-jsx-attributes-vertically))

    (defun jtsx-bind-keys-to-jtsx-jsx-mode-map ()
      (jtsx-bind-keys-to-mode-map jtsx-jsx-mode-map))

    (defun jtsx-bind-keys-to-jtsx-tsx-mode-map ()
      (jtsx-bind-keys-to-mode-map jtsx-tsx-mode-map))

    (add-hook 'jtsx-jsx-mode-hook 'jtsx-bind-keys-to-jtsx-jsx-mode-map)
    (add-hook 'jtsx-tsx-mode-hook 'jtsx-bind-keys-to-jtsx-tsx-mode-map))
#+end_src
*** Typescript REPL
#+begin_src elisp
  (use-package ts-comint
    :custom
    (ts-comint-program-command "ts-node"))

  (use-package ts-repl
    :ensure (:repo "nverno/ts-repl" :fetcher github :files ("*.el")))
#+end_src
** Roc
#+begin_src elisp
  (use-package roc-ts-mode
    :mode ("\\.roc\\'" . roc-ts-mode)
    :ensure (:repo "tad-lispy/roc-ts-mode" :fetcher gitlab :files ("*.el")))
#+end_src
** C
#+begin_src elisp
  (use-package c-ts-mode
    :custom
    (c-ts-mode-indent-offset 4)
    :ensure nil)
#+end_src
** Code folding
#+begin_src elisp
  (use-package treesit-fold
    :commands (global-treesit-fold-indicators-mode)
    :bind
    (:map treesit-fold-mode-map ("C-=" . treesit-fold-toggle))
    :hook
    (typescript-ts-base-mode . treesit-fold-mode))
#+end_src
** Snippets
#+begin_src elisp
  (use-package yasnippet-snippets)
  (use-package yasnippet
    :custom
    (yas-wrap-around-region t)
    (yas-also-auto-indent-first-line t)
    :hook
    (prog-mode . yas-minor-mode-on)
    (emacs-lisp-mode . yas-minor-mode-on)
    (text-mode . yas-minor-mode-on)
    :bind (:map yas-minor-mode-map
                ("C-<tab>" . yas-expand))
    :config
    (setq yas-snippet-dirs
          `(,(concat user-emacs-directory "snippets")
            ,yasnippet-snippets-dir))
    (yas-reload-all))
#+end_src
** Highlight indent guides
#+begin_src elisp
  (use-package highlight-indent-guides
    :custom
    (highlight-indent-guides-auto-even-face-perc 19)
    (highlight-indent-guides-auto-odd-face-perc 11)
    (highlight-indent-guides-auto-top-even-face-perc 30)
    (highlight-indent-guides-auto-top-odd-face-perc 25)
    :config
    (setq highlight-indent-guides-method 'fill
          highlight-indent-guides-responsive 'top
          highlight-indent-guides-auto-enabled t)
    ;; (set-face-foreground 'highlight-indent-guides-character-face "dimgray")
    :hook (prog-mode . highlight-indent-guides-mode))
#+end_src
** Elisp
#+begin_src elisp
  (use-package erefactor
    :bind-keymap ("C-c C-v" . erefactor-map)
    :hook (emacs-lisp-mode . erefactor-lazy-highlight-turn-on))
#+end_src
** Yaml
#+begin_src elisp
  (use-package yaml-ts-mode
    :ensure nil
    :mode ("\\.gotmpl\\'"))
#+end_src
** Ocaml
#+begin_src elisp
(use-package tuareg
  :mode (("\\.ocamlinit\\'" . tuareg-mode))
  :custom-face
  (tuareg-font-lock-constructor-face ((t (:inherit font-lock-type-face))))
  :bind (:map tuareg-mode-map
              ("C-c C-N" . xref-find-references-and-replace)
              ("C-c C-e" . tuareg-eval-phrase)
              ("C-c C-R" . tuareg-eval-region)))

(use-package merlin
  :config
  (exec-path-from-shell-initialize)
  (setq merlin-error-after-save nil)
  :hook (tuareg-mode))

(use-package merlin-eldoc
  :hook (tuareg-mode . merlin-eldoc-setup))
#+end_src
* Appearance
** Mode line
#+begin_src elisp
  (use-package doom-modeline
    :demand t
    :custom
    (doom-modeline-percent-position nil)
    (doom-modeline-time-icon nil)
    (doom-modeline-time nil)
    (doom-modeline-buffer-encoding nil)

    :config
    (doom-modeline-mode 1))
#+end_src
** Theme
#+begin_src elisp
  (use-package doom-themes
    :demand t
    :custom
    (doom-monokai-classic-brighter-comments nil)
    (doom-monokai-classic-comment-bg t)
    :config
    (load-theme 'doom-monokai-classic))
#+end_src
** Spacious padding
#+begin_src elisp
  (use-package spacious-padding
    :demand t
    :config (spacious-padding-mode 1))

  (use-package iedit
    :bind ("C-;" . iedit-mode))
#+end_src
* Grep
#+begin_src elisp
  (use-package rg
    :custom
    (wgrep-auto-save-buffer t)
    :bind
    ("M-g d" . rg-dwim))

  (use-package wgrep)

  (defun bob/monorepo-root ()
    "Finds the topmost root in a multi-project structure."
    (or (-some--> (project-current nil (file-name-parent-directory default-directory))
          project-root
          (let ((default-directory it))
            (bob/monorepo-root)))
        (-some-> (project-current) project-root)))

  (defun bob/deadgrep-project ()
    "Open an Eat shell on the highest project"
    (interactive)
    (if-let* ((project--root (bob/monorepo-root)))
        (deadgrep--lookup-override project--root)
      (error "Not in project")))

  (use-package deadgrep
    :init
    (setq deadgrep--skip-if-hidden t)
    :custom
    (deadgrep-project-root-function #'bob/deadgrep-project)
    (deadgrep--skip-if-hidden t)
    :bind ("M-g D" . deadgrep))
#+end_src
* CSV
#+begin_src elisp
  (use-package csv-mode)
#+end_src
* Treesiter
#+begin_src elisp
  (defun bob/install--grammer-if-missing (language)
    (unless (treesit-language-available-p language)
      (treesit-install-language-grammar language)))

  (use-package treesit
    :ensure nil
    :custom
    (treesit-font-lock-level 4)
    :config
    (setq treesit-language-source-alist
          '((bash . ("https://github.com/tree-sitter/tree-sitter-bash"))
            (c . ("https://github.com/tree-sitter/tree-sitter-c"))
            (cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
            (css . ("https://github.com/tree-sitter/tree-sitter-css"))
            (cmake . ("https://github.com/uyha/tree-sitter-cmake"))
            (csharp     . ("https://github.com/tree-sitter/tree-sitter-c-sharp.git"))
            (dockerfile . ("https://github.com/camdencheek/tree-sitter-dockerfile"))
            (elisp . ("https://github.com/Wilfred/tree-sitter-elisp"))
            (go . ("https://github.com/tree-sitter/tree-sitter-go"))
            (gomod      . ("https://github.com/camdencheek/tree-sitter-go-mod.git"))
            (html . ("https://github.com/tree-sitter/tree-sitter-html"))
            (java       . ("https://github.com/tree-sitter/tree-sitter-java.git"))
            (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
            (json . ("https://github.com/tree-sitter/tree-sitter-json"))
            (lua . ("https://github.com/Azganoth/tree-sitter-lua"))
            (make . ("https://github.com/alemuller/tree-sitter-make"))
            (ocaml . ("https://github.com/tree-sitter/tree-sitter-ocaml" nil "ocaml/src"))
            (org . ("https://github.com/milisims/tree-sitter-org"))
            (python . ("https://github.com/tree-sitter/tree-sitter-python"))
            (php . ("https://github.com/tree-sitter/tree-sitter-php"))
            (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" nil "typescript/src"))
            (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" nil "tsx/src"))
            (ruby . ("https://github.com/tree-sitter/tree-sitter-ruby"))
            (rust . ("https://github.com/tree-sitter/tree-sitter-rust"))
            (sql . ("https://github.com/derekstride/tree-sitter-sql" "gh-pages"))
            (vue . ("https://github.com/merico-dev/tree-sitter-vue"))
            (yaml . ("https://github.com/ikatyang/tree-sitter-yaml"))
            (toml . ("https://github.com/tree-sitter/tree-sitter-toml"))
            (zig . ("https://github.com/maxxnino/tree-sitter-zig")))

          major-mode-remap-alist
          '((c-mode          . c-ts-mode)
            (c++-mode        . c++-ts-mode)
            (c-or-c++-mode   . c-or-c++-ts-mode)
            (cmake-mode      . cmake-ts-mode)
            (conf-toml-mode  . toml-ts-mode)
            (css-mode        . css-ts-mode)
            (js-mode         . js-ts-mode)
            (java-mode       . java-ts-mode)
            (js-json-mode    . json-ts-mode)
            (python-mode     . python-ts-mode)
            ;; (sh-mode         . bash-ts-mode)
            (typescript-mode . typescript-ts-mode)
            (rust-mode       . rust-mode)))

    (add-to-list 'auto-mode-alist '("CMakeLists\\'" . cmake-ts-mode))
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
    (add-to-list 'auto-mode-alist '("\\.y[a]?ml\\'" . yaml-ts-mode))
    (bob/install--grammer-if-missing 'yaml)
    (bob/install--grammer-if-missing 'json)
    (bob/install--grammer-if-missing 'rust)
    (bob/install--grammer-if-missing 'typescript)
    (bob/install--grammer-if-missing 'tsx)
    (bob/install--grammer-if-missing 'javascript)
    (bob/install--grammer-if-missing 'python)
    (bob/install--grammer-if-missing 'c)
    (bob/install--grammer-if-missing 'cpp)
    (bob/install--grammer-if-missing 'zig)
    (bob/install--grammer-if-missing 'bash))
#+end_src
* Bash mode
#+begin_src elisp
  (use-package sh-script
    :ensure nil
    :mode ("\\.sh\\'" . bash-ts-mode)
    :interpreter ("bash" . bash-ts-mode))
#+end_src
* Postgres
#+begin_src elisp
  (use-package pg)
  (use-package pgmacs
    :ensure (:repo "emarsden/pgmacs" :fetcher github :files ("*.el"))
    :custom (pgmacs-row-limit 600)
    :config
    (setenv "POSTGRES_DATABASE" "grain")
    (setenv "POSTGRES_USER" "postgres")
    (setenv "POSTGRES_PASSWORD" "grain"))
#+end_src
* Grain utils
#+begin_src elisp
  (defun bob/generate--run-service-command (service-name &optional env inspect-port)
    "Generate a shell command to run SERVICE-NAME.
  optionally, accept ENV and INSPECT-PORT arguments."
    (format "NODE_ENV=%s TS_NODE_PROJECT='./apps/backend/%s/tsconfig.app.json' TS_NODE_FILES=true nodemon --ext ts --watch './apps/backend/%s/src/**/*' --exec \"node --inspect%s -r ts-node/register -r tsconfig-paths/register ./apps/backend/%s/src/index.ts\""
            (or env "")
            service-name
            service-name
            (if inspect-port (format "=%s" inspect-port) "")
            service-name))

  (defun bob/generate--run-all-services-command (excluded-service-name)
    "Run all off grain services except EXCLUDED-SERVICE-NAME."
    (format "npx nx run-many --target=start --parallel=20 --exclude=%s"
            excluded-service-name))

  (defun bob/generate--run-all-services-e2e-command (excluded-service-name)
    "Run all off grain services in e2e mode, except EXCLUDED-SERVICE-NAME."
    (format "npm run start:services:test -- --exclude %s"
            excluded-service-name))

  (defconst *grain-services-root* "apps/backend/")

  (defun grain/run--service (run-service-command service-output-buffer-name)
    "Run RUN-SERVICE-COMMAND in SERVICE-OUTPUT-BUFFER-NAME buffer."
    (let ((default-directory (bob/monorepo-root))
          (process (get-buffer-process (get-buffer service-output-buffer-name))))
      (when process
        (interrupt-process process)
        (kill-buffer (process-buffer process)))
      (async-shell-command run-service-command service-output-buffer-name)))

  (defun grain/get--service-name ()
    "Use completing read to get a name of a known grain service."
    (completing-read "Enter service name: "
                     (directory-files (file-name-concat (bob/monorepo-root) *grain-services-root*)
                                      nil
                                      "^[^.]")))
  ;;;###autoload
  (defun grain/run-service (single-service-p)
    "Run a service in debug mode.
  When SINGLE-SERVICE-P is nil, run all the other services as well."
    (interactive "P")
    (let* ((service-name (grain/get--service-name))
           (service-output-buffer (format "*SERVICE: %s*" service-name))
           (all-services-output-buffer (format "*[ALL] except %s*" service-name)))
      (save-excursion
        (grain/run--service
         (bob/generate--run-service-command service-name
                                            ""
                                            (get-next-available-inspect-port))
         service-output-buffer))
      (unless single-service-p
        (grain/run--service (bob/generate--run-all-services-command service-name)
                            all-services-output-buffer))
      (unless (get-buffer "*Dashboard*")
        (grain/run--service "npm run dev -w @grain/dashboard"
                            "*Dashboard*"))
      (unless (get-buffer "*Admin Console*")
        (grain/run--service "npm run dev -w @grain/admin-console"
                            "*Admin Console*"))
      (switch-to-buffer service-output-buffer)))

  ;;;###autoload
  (defun grain/run-e2e ()
    "Run a service in debug mode and all the other services as well."
    (interactive)
    (let ((service-name (grain/get--service-name)))
      (progn
        (grain/run--service (bob/generate--run-service-command service-name
                                                               "test"
                                                               (get-next-available-inspect-port))
                            (format "*SERVICE: %s*" service-name))
        (grain/run--service (bob/generate--run-all-services-e2e-command service-name)
                            (format "*[ALL] except %s*"
                                    service-name)))))
  ;;;###autoload
  (defun get-next-available-inspect-port (&optional default-port)
    "Calculate the next available port for node inspector to use.
  When all ports are available use DEFAULT-PORT or return 9229."
    (if-let ((inspected-ports (mapcar 'cdr (get-inspected-node-processes))))
        (->> inspected-ports
             (-sort #'string>)
             (car)
             (string-to-number)
             (1+))
      (or default-port 9229)))

  ;;;###autoload
  (defun pick-port-for-inspected-service ()
    "Ask for a service and find it's debugging port for."
    (let ((inspected-services-map (get-inspected-node-processes)))
      (-> (completing-read "Service to debug: "
                           inspected-services-map)
          (assocdr inspected-services-map)
          (or "9229"))))

  (defun get-inspected-node-processes ()
    "Get node processes that is running using the --inspect flag."
    (-filter 'identity (mapcar 'find--port-and-service-name-from-process-command
                               (mapcar #'process-command (process-list)))))

  (defun find--port-and-service-name-from-process-command (process-command)
    "Extract the service-name and port from PROCESS-COMMAND."
    (--some (or (port-and-service-name it)
                (jest-port-and-service-name it))
            process-command))

  (defun jest-port-and-service-name (proc-command)
    "Get the inspected port and service name when PROC-COMMAND is a Jest run command."
    (when-let* ((port-and-name (string-match jest-port-and-service-name-regex
                                             proc-command))
                (service-name (match-string 2 proc-command))
                (port (match-string 1 proc-command)))
      (cons (format "jest/%s" service-name) port)))

  (defconst jest-port-and-service-name-regex
    (rx (: "node --inspect"
           (*? anychar)
           "="
           (group (1+ digit))
           space
           (*? anychar)
           "jest"
           (*? anychar)
           "apps/backend/"
           (group (+? anychar))
           "/")))

  (defun port-and-service-name (proc-command)
    "Get the inspected port and service name from PROC-COMMAND."
    (when-let ((port-and-name (string-match port-and-service-name
                                            proc-command)))
      (let ((service-name (match-string 2 proc-command))
            (port (match-string 1 proc-command)))
        (cons service-name port))))

  (defconst port-and-service-name
    (rx (: "node --inspect"
           (*? anychar)
           "="
           (group (1+ digit))
           space
           "-r ts-node/register"
           (*? anychar)
           "apps/backend/"
           (group (+? anychar))
           "/"
           (*? anychar))))

  (ert-deftest generate-command ()
    (should (equal (bob/generate--run-service-command "mail-service") "NODE_ENV= TS_NODE_PROJECT='./apps/backend/mail-service/tsconfig.app.json' TS_NODE_FILES=true nodemon --exec \"node --inspect -r ts-node/register -r tsconfig-paths/register ./apps/backend/mail-service/src/index.ts\"")))

  ;;;###autoload
  (defun debug-migration ()
    "Debug a grain migration script."
    (interactive)
    (let ((runOrRevert (completing-read "Command: " '("run" "revert")))
          (default-directory "/Users/bob/source/grain/packages/rdb/"))
      (async-shell-command (format "node --inspect --require ts-node/register ../../node_modules/typeorm/cli.js migration:%s -d src/data-source.ts"
                                   runOrRevert)
                           "*migration-shell*")))

  (global-set-key (kbd "C-c C-r") 'grain/run-service)

  (defvar *local-pg-connection* nil
    "Connection to local PostgreSQL database.")
  (defvar *prod-pg-connection* nil
    "Connection to production PostgreSQL database.")
  (defconst *grain-select-from-prod-query-template* "select * from historical_exchange_rates where from_currency = '%s' and to_currency = '%s' order by timestamp DESC limit 1;")
  (defconst *grain-insert-from-prod-query-template*
    "INSERT INTO historical_exchange_rates (from_currency, to_currency,\"timestamp\",\"quote\",created_at,updated_at,deleted_at) VALUES
  	 ('%s','%s','%s',%f,'%s','%s',NULL);")
  (defun pg--date-string (timestamp)
    (format-time-string "%Y-%m-%d %H:%M:%S" timestamp))
  (defun grain-insert-rates-query (prod-rates)
    (let ((from-currency (nth 0 prod-rates))
          (to-currency (nth 1 prod-rates))
          (timestamp (pg--date-string (nth 2 prod-rates)))
          (quote (nth 3 prod-rates))
          (created-at (pg--date-string (nth 4 prod-rates)))
          (updated-at (pg--date-string (nth 5 prod-rates))))
      (format *grain-insert-from-prod-query-template*
              to-currency
              from-currency
              timestamp
              quote
              created-at
              updated-at)))

  (defun import-rate-from-prod (from to)
    "Import rate from prod using FROM as and TO currencies"
    (interactive "sFrom currency: \nsTo currency: ")
    (let* ((auth-entry (auth-source-search :host "grain-prod-postgres" :max 1))
           (user (plist-get (car auth-entry) :user))
           (password (funcall (plist-get (car auth-entry) :secret)))
           (url (plist-get (car auth-entry) :url))
           (prod-rates (with-pg-connection prod-pg-connection
                         ("grain" user password url 5432)
                         (pg-result (pg-exec prod-pg-connection (format *grain-select-from-prod-query-template* from to))
                                    :tuple 0 ))))
      (with-pg-connection local-pg-connection ("grain" "postgres" "grain" "localhost" 5432)
        (pg-result (pg-exec local-pg-connection
                            (grain-insert-rates-query prod-rates))
                   :tuples))))
#+end_src
* Multiple Cursors
#+begin_src elisp
  (use-package multiple-cursors
    :bind
    ("C-S-c C-c" . mc/edit-lines)
    ("C-S-c C->" . mc/mark-next-like-this)
    ("C-S-c C-<" . mc/mark-previous-like-this)
    ("C-S-c C-." . mc/mark-all-like-this))
#+end_src
* String inflection
#+begin_src elisp
  (use-package string-inflection)
#+end_src
* Move lines
#+begin_src elisp
  (defun move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (bind-key "C-S-p" 'move-line-up)
  (bind-key "C-S-n" 'move-line-down)
#+end_src
* Ligature
#+begin_src elisp
  (use-package ligature
    :demand t
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+end_src
* Terminal emulation
#+begin_src elisp
  (use-package eat
    :commands (eat eat-project bob/eat-top-project)
    :custom
    (eat-term-scrollback-size nil)
    :init
    (setq eat-term-name "xterm-256color")
    :bind
    ("C-!" . eat)
    ("C-c s j" . bob/jump-to-shell)
    ("C-x p s" . eat-project)
    ("C-x p S" . bob/eat-top-project))

  (use-package xterm-color
    ;; :demand t
    ;; :hook
    ;; (compilation-filter . #'xterm-color-filter)
    :custom
    (compilation-environment '("TERM=xterm-256color")))
#+end_src
* RSS feed
#+begin_src elisp
  (use-package elfeed
    :custom
    (elfeed-feeds
     '(("https://learncodethehardway.com/feed.rss" programming learning c)
       ("https://feeds.transistor.fm/thoughts-on-functional-programming-podcast-by-eric-normand" programming lisp)
       ("https://www.reddit.com/r/emacs/.rss" programming emacs reddit)
       ("https://www.reddit.com/r/roc_lang/.rss" programming roc reddit)
       ("https://www.reddit.com/r/planetemacs/.rss" programming emacs reddit)
       ("https://danluu.com/atom.xml" programming blog danluu)
       ("https://protesilaos.com/master.xml" programming blog emacs)
       ("https://eshelyaron.com/rss.xml" programming blog emacs)))
    :bind
    ("C-c w" . elfeed)
    (:map elfeed-search-mode-map
          ("T" . bob/elfeed-search-by-current-entry-tags)
          ("t". bob/elfeed-reset-search-by-current-entry-tags))
    :config
    (defun bob/elfeed-search-by-current-entry-tags ()
      "Display elfeed entries that have the same tags as the entry under the cursor."
      (interactive)
      (elfeed-search-set-filter
       (s-trim (mapconcat
                (lambda (tag)
                  (format " +%s" tag))
                (elfeed-entry-tags (elfeed-search-selected :ignore-region))))))

    (defun bob/elfeed-reset-search-by-current-entry-tags ()
      (interactive)
      (elfeed-search-set-filter "+unread")))
#+end_src
* Spelling
#+begin_src elisp
  (use-package jinx
    :custom
    (jinx-include-faces '((prog-mode font-lock-variable-name-face
                                     font-lock-comment-face
                                     font-lock-doc-face
                                     font-lock-string-face
                                     git-commit-summary)
                          (conf-mode font-lock-comment-face font-lock-string-face)
                          (yaml-mode . conf-mode)
                          (yaml-ts-mode . conf-mode)))
    :config
    (add-to-list 'jinx-camel-modes 'roc-ts-mode)
    :init
    (message "Loading Jinx")
    (global-jinx-mode)
    :bind (("M-$" . jinx-correct)
           ("C-M-$" . jinx-languages)))
#+end_src
* Proceed Narrow
#+begin_src elisp
  (use-package proced-narrow
    :bind (:map proced-mode-map ("N" . proced-narrow)))
#+end_src
* Avy
#+begin_src elisp
  (use-package avy
    :custom
    (avy-case-fold-search t)
    (avy-timeout-seconds 0.25)
    :bind
    ("C-:" . avy-goto-char-timer)
    (:map isearch-mode-map
          ("C-:" . avy-isearch)))
#+end_src
* Ace Window
#+begin_src elisp
  (use-package ace-window
    :bind
    ( "C-x o" . ace-window)
    ( "M-o" . ace-window)
    :config
    (setq aw-scope 'frame)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src
* Golden ratio
#+begin_src elisp
  (use-package golden-ratio
    :bind
    ("C-x -" . bob/golden-ratio)
    :config
    (add-to-list 'golden-ratio-extra-commands 'ace-window)
    (defun bob/golden-ratio ()
      "Toggle golden ratio"
      (interactive)
      (if golden-ratio-mode
          (progn (golden-ratio-mode -1)
                 (balance-windows))
        (progn (golden-ratio-mode)
               (golden-ratio)))))

#+end_src
* Kubed
#+begin_src elisp
  (use-package kubed)
#+end_src
* Combobulate
#+begin_src elisp
  (use-package combobulate
    :ensure (:repo "mickeynp/combobulate" :fetcher github :files ("*.el"))
    :custom
    (combobulate-key-prefix "C-c o")
    :bind
    (:map typescript-ts-mode-map ("C-M-SPC" . combobulate-mark-node-dwim))
    (:map tsx-ts-mode-map ("C-M-SPC" . combobulate-mark-node-dwim)) :hook (typescript-ts-mode))

#+end_src
* macrostep
#+begin_src elisp
  (use-package macrostep
    :bind (:map emacs-lisp-mode-map ("C-x E" . macrostep-expand)))

#+end_src
* hide-show
#+begin_src elisp
  (use-package hideshow :ensure nil
    :hook (emacs-lisp-mode . (lambda () (hs-minor-mode 1)) )
    :bind (:map emacs-lisp-mode-map ("C-=" . hs-toggle-hiding)))
#+end_src

#+end_src
* org-linear
#+begin_src elisp
  (use-package org-linear
    :ensure (org-linear
             :host github
             :repo "bobrowadam/org-linear"
             :main "org-linear.el"
             :files ("org-linear.el"
                     "index.ts"
                     "package.json"
                     "tsconfig.json")
             :build (:not elpaca--compile-info)
             :pre-build (("bun" "install"))))
#+end_src

#+end_src
* linear
#+begin_src elisp
  (use-package linear-emacs
    :custom (linear-api-key (getenv "LINEAR_API_KEY"))
    :ensure (:repo "anegg0/linear-emacs" :fetcher github :files ("*.el")))
#+end_src

#+end_src
* p-search
#+begin_src elisp
  (use-package p-search
    :commands p-search
    :ensure (:repo "zkry/p-search" :fetcher github :files ("*.el")))
#+end_src

#+end_src
* sly
#+begin_src elisp
  (use-package sly
    :custom
    (inferior-lisp-program "sbcl")
    :config
    (setq sly-lisp-implementations
          '((nyxt ("sbcl" "--dynamic-space-size 3072")
                  :env ("CL_SOURCE_REGISTRY=~/common-lisp//:~/common-lisp/nyxt/_build//")))))
#+end_src

#+end_src
* common-lisp
** Sly
#+begin_src elisp
  (use-package sly-repl-ansi-color
    :after (sly)
    :init (push 'sly-repl-ansi-color sly-contribs))
  (use-package sly-asdf)
  (use-package sly-macrostep)
#+end_src
* Enabled commands that are disabled by default
#+begin_src eslip
(put 'narrow-to-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'set-goal-column 'disabled nil)
#+end_src
